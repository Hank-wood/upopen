{"_id":{"$oid":"57214dea772850cb0a90d787"},"comment":0,"tags":"other","kind":"other","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-04-27T13:02:19.712Z"},"content":"### 一、安装\n\u003e可以到npmjs.org上搜索marked 或 markdown，都可以作为解析器\n```js\nnpm install marked --save\n```\n---\n\n### 二、语法\n**注意不同的md解析出来的结果是不一样的。但大致是相同的**\n#### 1、段落\n**段落** 其在html表现为用一个 **P** 标签，md实现需要在段落的前后各加一空行，如本行与下一段落之间插入了一个空行，实现了本行HTML的 **P** 标签。\n  \n#### 2、换行\n**换行** 在html表现为一个\u003cbr /\u003e，可以在行尾加两个空格，再换行写其文本  \n如本行与上一行\n\n#### 3、标题\n在HTML生成h1...h5标签，提供两种形式\n##### a、atx\n在需要设置标题的前面加 **#** 符号，据数量1..5，分别对应h1...h5，注意符号与标题间留一空格  \n```js\n# h1\n### h3\n##### h5\n```\n# h1\n### h3\n##### h5\n##### b、Setext\n只支持h1 / h2，通过在标题下加 **=** / **-** 设置\n```js\nH1\n===\nh2\n---\n```\nH1\n===\nh2\n---\n#### 4、引用\n引用在html表现为 **blockquote** 标签\n\u003e这里是引用1  \n\u003e这里是多行引用2\n\u003e\u003e这里里嵌套引用1.1\n\u003e\u003e\u003e嵌套引用里可以使用 **markdown** 语法\n\n#### 5、列表\n分有序和无序，有序表现为 **ol**，无序表现为 **ul**， 不同的md解析出来的会有不同\n```js\n* 这里是列表项1\n* 这里是列表项2\n+ 这里是列表项2\n- 这里是列表项3\n```\n* 这里是列表项1\n* 这里是列表项2\n+ 这里是列表项2\n- 这里是列表项3\n\n```js\n1. 有序列表\n2. 以数字和.开始\n4. 但显示时的数字不以编辑时的数字显示\n```\n1. 有序列表\n2. 以数字和.开始\n4. 但显示时的数字不以编辑时的数字显示\n\n```js\n1. 有序无序可以相互嵌套\n  * 缩近两个空格嵌套近来一个无序的\n  * 和另外一个无序的\n2. 这个是有序的\n```\n1. 有序无序可以相互嵌套\n  * 嵌套近来一个无序的\n  * 和另外一个无序的\n2. 这个是有序的\n\n#### 6、代码块\nhtml表现为 **code** 标签，可以将代码块包含在 ```  符号内\n```js\n\u003ctable\u003e\n    \u003ctr\u003e\n        \u003ctd\u003e1\u003c/td\u003e\n    \u003c/tr\u003e\n\u003c/table\u003e\n```\n\n#### 7、分隔线\nhtml表现为 \u003chr\u003e，在一行内使用三个 _\n```js\n正面这个表现为 \u003chr\u003e\n___\n```\n___\n\n#### 8、超链接\nhtml表现为 \u003ca href=\"\"\u003etext\u003c/a\u003e\n##### a、行内式\n格式为[ link text]( url 'title text')，title可省略\n```js\n[upopen](http://www.upopen.cn 'upopen.cn')\n```\n[upopen](http://www.upopen.cn 'upopen.cn')\n\n也可以指向本地链接\n```js\n[blog nodejs](./blog/list?kind=nodejs)\n```\n[blog nodejs](./blog/list?kind=nodejs)\n\n##### b、\u0008自动链接\n使用\u003c\u003e将url括起来，简单方便\n```js\n\u003chttp://www.upopen.cn\u003e\n```\n\u003chttp://www.upopen.cn\u003e\n\n#### 9、图片\n使用上同超链接，只前面加!\n```js\n![head pic](http://www.upopen.cn/public/imgs/head.png '用户头像')\n```\n![head pic](http://www.upopen.cn/public/imgs/head.png '用户头像')\n\n#### 10、强调\n使用 \\*\\*Txt\\*\\* 实现 \u003cstrong\u003e，使用 \\*Em\\* 实现 \u003cem\u003e\n```js\n**这里是加粗文字**\n*这里是斜体*\n```\n**这里是加粗文字**  \n*这里是斜体*\n\n#### 11、转义\nmd多数编译都是通过符号来声明的，对原符号本身的使用需要使用转义符 **\\**\n```js\n这样写是 **加粗**\n这样写就知道为什么会 \\*\\*加粗\\*\\*\n需要转义的符号有\n` * _ - { } [ ] ( ) # ! . + ~\n```\n这样写是 **加粗**   \n这样写就知道为什么会 \\*\\*加粗\\*\\*\n\n#### 12、删除线\n使用 \\~\\~删除线\\~\\~，html表现为 \u003cdel\u003e\n~~删除线~~\n\n#### 13、表格\n使用 - | 来划分表头及单元格\n```js\n| name | age | height |\n| :----    | :---:   | ----:    |\n| jxiao  | 12   | 176     |\n| Mike  |  32  | 172     |\n---: 表示向哪方对齐\n```\n| name |  age  | height |\n| :----    | :---:   | ----:    |\n| jxiao  | 12   | 176     |\n| Mike  |  32  | 172     |\n\n### 三、IDE工具\n目前提供了很多md的IDE工具，如 MacDown / Mou / Haroopad / sublime-markdown-extended 等\n\n### 四、参考\n\u003e学习markdown时，参考了 \u003chttp://xianbai.me/learn-md/\u003e ，其也有更详细的介绍","summary":"\u0008markdow是一种轻量级标记语言，以Text 2 Html为目的，其在原理上多借鉴了email中的文本特性。相对于各开源的富文本编辑器，其简单易用，且兼顾html的语法，其扩展名可用md，所以可用md作简称。本站亦使用","title":"markdown","__v":0}
{"_id":{"$oid":"5722ad15b190d1a902ab38f4"},"comment":0,"tags":"other","kind":"other","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-04-28T23:54:11.486Z"},"content":"### 一、介绍\n[sass官网](http://sass-lang.com/)\n\nsass文件有两种后缀名 .sass / .scss，差异在于前者编写时不需要加 *{}* 和 *:*，而后者在这一点上和css相同，本文介绍时都使用后者。\n```css\n//.sass\nbody\n  background:#fff;\np\n color: #f00\n\n//.scss\nbackground{\n background:#fff;\n}\np{\n  color:#f00;\n}\n```\n### 二、安装\nsass基于ruby，需要先安装ruby，以mac为例，因为mac已经安装了ruby，可以直接调用gem\n```js\n//安装\ngem install sass\n//安装有时会失败，gem的数据源在国外，或许是会网络总是导致失败，和nodejs npm 类似，可以修改数据源\n//移除原source\ngem sources --remove https://rubygems.org/\n//添加taobao镜像source\ngem sources -a https://ruby.taobao.org/\n//查看修改后的source\ngem sources -l\n//查看安装版本，以确认是否安装成功\nsass -v\n```\n其它相关命令还有\n\n```js\n//更新\ngem update sass\n//查看帮助\nsass -h\n```\n\n### 三、编译\n写好scss文件后，需要通过前面安装好的sass将其编译成css\n\n先简单创建一个scss文件，定义目录如下\n\n```\n* demo/\n  + scss/\n    - style.scss\n  + css/\n```\nscss/style.scss，插入如下代码\n```js\n//定义变量\n$bgColor: #foo;\nbody{\n  background: $bgColor\n}\n```\n执行编译\n\n#### 1、单文件编译\n```\nsass scss/style.scss css/style.css\n```\n编译后，css文件下生成style.css\n```css\nbody {\n  background: #f00; }\n```\n#### 2、文件监听编译\n```\nsass --watch scss/style.scss:css/style.css\n```\n\n#### 3、监听文件夹\n```\nsass --watch scss:css\n```\n#### 4、css也可以转换为sass，不过意义不大 \n```\nsass-convert css/style.css scss/style.scss\n```\n\n#### 5、其它一些配置项\n可以使用 --style，--sourcemap\n```\n//开启sourcemap调度，生成.css.map文件\nsass --watch scss:css --sourcemap\n```\n\n```\nsass --watch scss:css --style nested\n```\n\n--style 可以跟四种值 expanded[展开] / nested[嵌套] / compact[紧凑] / compressed[压缩]\n\n实际开发过程中需要对scss文件保存即编译成css，可以使用sass --watch，也可以使用ide插件，我开发时使用gulp，所以会将sass集成到gulp，执行gulp watch，可参见 [gulp使用](http://www.upopen.cn )\n\n### 四、语法\n#### 1、导入\nsass可以通过@import导入*.css和*.scss，其中.css是一样的，但对.scss的引入略有不同  \n* 可以省略后缀名\n* 被引入的文件名，可以下划线命令名 *_name* 形式，但引入时可忽略_。这样的命名方式，用于区分基础文件\n* 被引入的.scss文件会合并到当前的.scss文件\n\n定义_color.scss\n```css\n$bgColor: #f0f;\n```\n定义style.scss\n```css\n@import 'reset.css'\n@import 'color'\nbody{\n  background: $bgColor;\n}\n```\n\n#### 2、注释\nsass的注释同js有两种，\n\n```css\n/**\n* 多行注释\n* 这样的注释编译到css里会被保留\n*/\n\n//这里是单行注释，被编译到css里不会被输出，因为css不支持这样的注释\n```\n\n#### 3、变量\n##### a、变量是sass中非常有用的一项，以$开头\n```css\n//sass\n$color: #ff0;\nbody{\n  color: $color;\n}\n\n//=\u003ecss\nbody{\n  color: #ff0;\n}\n```\n##### b、但对于作为属性的变量需要以#{$variablies}形式\n```css\n$borderDir: top;\n$borderStyle: solid;\n.header{\n border-#{$borderDir}: 1px $borderStyle #f00; \n}\n```\n##### c、作为特殊值时也是\n```css\n$fontSize: 12px;\n$fontLineHeight: 2;\n.header{\n font: #{$fontSize}/#{fontLineHeight}; \n}\n```\n##### d、多值变量\n\n#### 4、嵌套\n有两种嵌套选择器嵌套、属性嵌套来实现继承。\n##### a、选择器嵌套\n1. 是指一个选择器中嵌套另一个选择器，以使结构清晰，可用 *\u0026* 表示父选择器\n2. 属性嵌套，用于background / border这样属性\n3. @at-root可跳出选择器嵌套\n\n```css\n//sass，层级嵌套，结构清晰\nheader{\n  height: 100px;\n  font: #{$fontSize}/#{$fontLineHeight};\n  background: $bgWhiteColor;\n  border:{\n    style: solid;\n    width: 0;\n    bottom: {\n\u0009  width: 2px;\n\u0009  color: #0ff;\n    }\n  }\n  background:{\n\u0009  color: $bgWhiteColor;\n  }\n  .mininav{\n    height: 60px;\n    margin: 20px;\n    float: right;\n\u0009\u0009\n    a{\n      font-size: $fontSize;\n      color: $fontColor;\n      //\u0026 返回父选择器，相当于a:hover\u0009\u0009\n      \u0026:hover{\n        color: $fontHoverColor;\n      }\n      //@at-root 跳出所有选择器，相当于在与header平级定义了section\n      @at-root section{\n\u0009      background: #ff0;\n      }\n    }\n  }\n}\n\n//=\u003ecss\nheader {\n  height: 100px;\n  font: 14px/2em;\n  background: #fff;\n  border-style: solid;\n  border-width: 0;\n  border-bottom-width: 2px;\n  border-bottom-color: #0ff;\n  background-color: #fff;\n}\nheader .mininav {\n  height: 60px;\n  margin: 20px;\n  float: right;\n}\nheader .mininav a {\n  font-size: 14px;\n  color: #333;\n}\nheader .mininav a:hover {\n  color: #f00;\n}\nsection {\n  background: #ff0;\n}\n```\n\n#### 4、混合\n混合类似于js里的函数定义，可以使用函数，使用@mixin声明，通过@include调用\n\n```css\n//定义不带参数的 @mixin\n@mixin opacity{\n\u0009opacity: .7;\n\u0009filter: alpha(opacity=70);\n}\n\n//定义带参数的 @mixin\n@mixin opacityArg($opacity:50){ //默认值\n\u0009opacity: $opacity / 100;\n\u0009filter: alpha(opacity=$opacity);\n}\n//定义带多参的 @mixin\n@mixin wrapper( $wbgColor: #000, $width: 100px, $height: 100px ){\n\u0009width: $width;\n\u0009height: $height;\n\u0009background: $wbgColor;\n}\n\n//定义多组值\n@mixin shadow( $shadow... ){\n\u0009-webkit-box-shadow: $shadow;\n\u0009box-shadow: $shadow;\n}\n\n.box{\n\u0009@include opacity;\n\u0009@include wrapper;\n}\n\n.box1{\n\u0009@include opacityArg;\n\u0009@include wrapper(#f00);\n}\n\n.box2{\n\u0009@include opacityArg( 80 );\n\u0009@include wrapper($width: 200px);\n\u0009@include shadow(0 2px 2px #ff02ff, 0 3px 3px #ff02ff, 0 4px 4px #ff02ff);\n}\n\n//=\u003ecss\n.box {\n  opacity: .7;\n  filter: alpha(opacity=70);\n  width: 100px;\n  height: 100px;\n  background: #000;\n}\n\n.box1 {\n  opacity: 0.5;\n  filter: alpha(opacity=50);\n  width: 100px;\n  height: 100px;\n  background: #f00;\n}\n\n.box2 {\n  opacity: 0.8;\n  filter: alpha(opacity=80);\n  width: 200px;\n  height: 100px;\n  background: #000;\n  -webkit-box-shadow: 0 2px 2px #ff02ff, 0 3px 3px #ff02ff, 0 4px 4px #ff02ff;\n  box-shadow: 0 2px 2px #ff02ff, 0 3px 3px #ff02ff, 0 4px 4px #ff02ff;\n}\n```\n#### 5、继承\nbrother @extend person，让一个选择器brother继承另一个选择器person的样式。\n```css\n.person{\n\u0009width: 100px;\n\u0009height: 100px;\n\u0009border: 10px solid #0f0;\n}\n//% 占位符，此类的定义，若未被引用，将不会被解析，以解析资源。\n%clearfix{\n\u0009clear: both;\n}\n%display{\n\u0009display: inline-block;\n}\n//对常规样式 及 占位符资源的引用\n.brother{\n\u0009@extend .person;\n\u0009@extend %clearfix;\n\u0009background: #f00;\n}\n\n//=\u003ecss\n.person, .brother {\n  width: 100px;\n  height: 100px;\n  border: 10px solid #0f0;\n}\n\n.brother {\n  clear: both;\n}\n\n.brother {\n  background: #f00;\n}\n```\n\n#### 6、函数\n\n#### 7、运算\n\n#### 8、if判断\n\n#### 9、for循环\n### 五、调试\n","summary":"提供了一种可以像写js一样编写css的解决方案，有设置变量、嵌套编写、css导入、扩展、继承等，使得css开发快捷也更易维护","title":"sass","__v":0}
{"_id":{"$oid":"572536e22b0c2f4e02c45f79"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-04-30T22:34:01.006Z"},"content":"与传统的客户端软件相比，前端是一种特殊的GUI软件，就特殊的在于其一切操作都是通过浏览器，资源也是实时获取（有部分本地缓存）。\n\n同比软件工程的定义，前端工程是用工程化的思维进行构建、维护有效的、实用的、高质量的前端应用。\n\n前端工程包括：\n* 组织架构：开发规范和架构设计，包括开发框架、目录规范、组织形式、语言规范等\n* 工程部署：部署方式，静态资源服务的CDN部署、缓存等\n* 性能优化：性能优化，按需要加载、打包合并、缓存\n* 工具平台：构建工具和开发平台\n* 开发流程：开发、测试、部署等\n* 统计监控：用户行为与网站状态监控，pv/uv、网站性能等。\u003chttp://tongji.baidu.com\u003e\n* 前端安全：安全防范的工程化方法，如xss / csrf等\n* 系统测试：前端系统测试的工程化方法\n\n浏览器缓存有两种\n1. 协商缓存：\n\u003e每次向服务器发查询请求，服务器告知该文件的修改与否，如未修改，则用本地，该文件的status code为304。因其每次请求都要建立连接查询，也需要一定时间。\n2. 本地缓存：\n即服务器发送资源时告知浏览器一定时间内无需向服务器咨询，这也是比较快捷的一种方式，status code为200，但size显示为 from cache，可以利用文件后的时间戳实现\n___\n**[本文章拜读了张云龙的文章，略加整理](https://github.com/fouber/blog/blob/master/201505/01.md)**","summary":"","title":"前端工程化","__v":0}
{"_id":{"$oid":"5729386c7297440b0aefad83"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"P(rocess)M(anager)2 是一个带有负载均衡的Node应用的进程管理器，其优势在于可利用服务器上的所有CPU，并保证进程永远都在线，0秒重载。其适合laaS（基础架构即服务）结构，不适于Pass方案(平台即服务)。其本身作为主进程，然后将项目封装到一个特殊的集群进程里，并对子进程做监控。upopen.cn里的nodejs项目运行全部依赖于pm2。开发阶段也可以用pm2-dev，实时查看log，不过我还是习惯用node-dev。\n\n简单来讲，优势有：\n\n1. 监听nodejs项目服务线程，保证其不会掉线\n\u003e其原理是pm2本身是一个主进程，nodejs项目是子进程，主进程监听子进程，当子进程意外停止时，主进程会去重启子进程，这在我们上线项目时是必要的，虽然我们可以用try..catch，domain，process等来捕捉意外逻辑错误，但其并不能解决全部问题，崩溃一个项目还有可能是内存溢出及各种软、硬件等问题。当然其并没有解决系统本身存在的漏洞，要做好日志监听、跟踪工作，以便崩溃时查找。\n\n2. 提供负载均衡，充分利用服务器高性能\n\u003e12年刚接触nodejs时，一个同事问我，nodejs是单线程的，那如何充分利用CPU呢，那个时候too young，说多复制几份，以不端口分别启动，通过nginx去负载。首先通过nginx是可以达到的，但nodejs的模块本身已经更好的提供了这个功能，即一次启动时，可以指定启动多少个进程来运行nodejs项目，单台服务上同一项目的多个nodejs进程负载，由pm2本身就可以完成，并且其还提供了很好的监按功能\n\n同类框架forever，不过后者功能少于pm2。\n\n特性：   \n1. 内建负载均衡（使用Node cluster集群模块）   \n2. 后台运行   \n3. 升级无需停机   \n4. 具有Ubuntu启动脚本   \n5. 停止不稳定的进程   \n6. 控制台检测   \n7. 提供Http API   \n8. 远程控制和实时的接口API（允许和PM2进程管理器交互）   \n     \n安装：\n```js\n    npm install -g pm2     //几乎都是全局使用\n\n    pm2 update          //更新pm2\n\nAPI：[标星部分，是据使用经验，较多使用]\n\n     pm2 start app.js -i 4     //*运行pm2，启动4个app.js，当设置个数超过cpu核数时，超出部分是没有意义的。\n     pm2 start app.js -i max //运行pm2，自动据CPU核心数尽量启动多的app.js\n     pm2 start app.js --name myNodejs     //*运行pm2，设置进程名，当多个项目启动时，需据进程名stop / restart...，upopen的服务器，同时启动了五个不同的nodejs项目，此时就需要据name来做不同的管理\n     pm2 start app.js --watch //启用监控，当文件被修改时，restart\n     pm2 start app.json     //启动进程，在app.json里设置选项\n     pm2 ls     //*显示所有进程状态，效果如下图\n```\n![pm2 ls](http://dl2.iteye.com/upload/attachment/0114/5353/f6ba6be1-b7d4-318e-b933-58ac86005756.jpg)\n\n```js\n     pm2 monit     //*监视所有进程，效果如下图\n```\n![pm2 monit](http://dl2.iteye.com/upload/attachment/0114/5355/740a4868-c42f-33a7-a77c-1031c0f49675.jpg)\n```js\n     pm2 logs  [\u003call|id|name\u003e]//*显示所有进程日志，pm2启动无法显示nodejs中的console.log，可以通过 pm2 logs查看\n     pm2 stop \u003call|id|name\u003e //*停止指定进程\n     pm2 reload \u003call|id|name\u003e    //*重载指定进程\n     pm2 restart \u003call|id|name\u003e    //*重启指定进程\n     pm2 delete \u003call|id|name\u003e     //*杀死指定进程\n     pm2 kill     //*杀死所有进程\n     pm2-dev run app.js  //开发模式，同node-dev\n```","summary":"P(rocess)M(anager)2 是一个带有负载均衡的Node应用的进程管理器，其优势在于可利用服务器上的所有CPU，并保证进程永远都在线，0秒重载。其适合laaS（基础架构即服务）结构，不适于Pass方案(平台即服务)。其本身作为主进程，然后将项目封装到一个特殊的集群进程里，并对子进程做监控。upopen.cn里的nodejs项目运行全部依赖于pm2。开发阶段也可以用pm2-dev，实时查看log，不过我还是习惯用node-dev。\n","title":"pm2","__v":0}
{"_id":{"$oid":"572938e57297440b0aefad84"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"后端服务常会用到邮件功能，如注册、修改密码等，nodejs的nodemailer第三方模块提供邮件的发送功能，我在upopen.cn中也有应用，用户注册成功后，server服务会发一封欢迎邮件到用户注册邮箱。\n\n基于nodemailer的二次封装在 server/lib/mailer.js，使用是在 server/server/user.js register\n\n使用如下:\n\n```js\n\u0009var transporter = require( 'nodemailer' );  //引用模块\n\u0009var transporter = nodemailer.createTransport({\n\u0009\u0009service: 'QQ',\n\u0009\u0009auth: {\n\u0009\u0009    user: '2270112418@qq.com',\n\u0009\u0009    pass: 'bscaehznqgaidhhi'\n\u0009\u0009}\n\u0009});\n  ```\nserver: 邮件服务器，这里用的QQ邮箱，不同服务商的邮件服务器名是不同的，本来我找到一个列表的，忘记放哪里了，随后再附。注意要到邮箱设置里开启 POP3 / SMTP服务，否则会报535错误   \nauth.user: 邮件帐号   \nauth.pass: POP3开启后，其会给出一组授权码，添写在此处 。注意不要写自己的邮箱登录密码\n```js\n\u0009function mail( config ){\n\n\u0009\u0009var mailOptions = {\n\u0009\u0009    from: '2270112418@qq.com',      \n                    //发件人帐号，要与上面的auth.user一致，否则会报501错误\n\u0009\u0009    to: config.to || '5858186@qq.com',     \n                    //收件人帐号\n\u0009\u0009    subject: config.subject || '\u003ch3\u003ehi, register success\u003c/h3\u003e', \n                    //邮件标题\n\u0009\u0009    text: config.subject || '\u003ch3\u003ehi, register success\u003c/h3\u003e', \n                    //邮件内容\n\u0009\u0009    html: config.html || '\u003ch3\u003ehi, register success\u003c/h3\u003e', \n                    //以html形式编写邮件内容\n\u0009\u0009    attachments: config.annex || [] \n                    //附件，值是数组\n\u0009\u0009};\n\n\u0009\u0009transporter.sendMail(mailOptions, function(error, info){\n\u0009\u0009    if(error){\n\u0009\u0009        console.log(error);\n\u0009\u0009    }else{\n\u0009\u0009        console.log('Message sent: ' + info.response);\n\u0009\u0009    }\n\u0009\u0009});\n\n\u0009}\n\n    module.exports = mail;\n```\n封装发送邮件的函数\n\n使用如\n\n```js\n\u0009mail({\n\u0009\u0009to: redisData.username,\n\u0009\u0009subject: 'hi, welcome to upopen.cn',\n\u0009\u0009html: 'Congratulations, you have successfully registered as a member of upopen.cn,We won\\'t bother you unless you have to'\n\u0009});\n```","summary":"后端服务常会用到邮件功能，如注册、修改密码等，nodejs的nodemailer第三方模块提供邮件的发送功能，我在upopen.cn中也有应用，用户注册成功后，server服务会发一封欢迎邮件到用户注册邮箱。","title":"nodemailer","__v":0}
{"_id":{"$oid":"572939c67297440b0aefad85"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、简介\n\n  经过一个月+的开发，upopen.cn个人站点重构基本完成，本文先总结整体架构及主要技术点，后续再单独详解各技术点及开发过程。\n\n  首先重构的目的在于系统化架构、理清分离开发及服务端开发思维、尝试使用多的技术点，为提升公司项目的全栈应用做准备。\n\n本次共计三个服务[小部分技术点还在提交中]，整体采用前后端分离（web服务端，数据服务端），以restful API通信\n\n站点: !\u003cwww.upopen.cn\u003e\n\ngit: https://github.com/xiaolulu/upopen\n\nQQ群: 435485569\n\n---\n\n**系统功能**\n\nweb: web服务端\n\n  站点前台服务，属前后端分离中的前台，负责页面渲染、与客户端及server端的数据交互，使用http协议\n\u0009\nserver: 数据服务端\n\n  站点后台服务，属前后端分离中的后台，与web服务端及数据库的数据交互，不直接与客户端通信，实际项目中常会用java实现\n\ncheck:\n\n  属工具类服务，用于记录、验证接口功能，在前后端分离过程中，以方便并行开发\n\n=============================================================================\n\n### 二、系统架构\n![系统架构](http://dl2.iteye.com/upload/attachment/0114/3539/059e6c1b-6dda-34af-8296-0d370b7d7f17.png)\n\n\n### 三、系统目录\n\ndocs:系统文档\n\nlog: 系统日志，独立成单独的服务\n```js\n\u0009web/\n\u0009\n\u0009check/\n\n\u0009server/\n\ncheck: 接口记录、验证系统，整体采用MVSC结构，server、web系统也采用相同结构\n\n\u0009app.js\n\n\u0009package.json\n\n\u0009webpack.config.js\n\n\u0009assets/\u0009\u0009静态资源包\n\n\u0009build/\u0009\u0009react打包后文件\n\n\u0009model/\u0009\u0009数据层\n\n\u0009views/\u0009\u0009展示层\n\n\u0009controls/\u0009控制层\n\n\u0009server/\u0009\u0009业务层\n\n\u0009lib/\u0009\u0009工具包\n\n\u0009config/\u0009\u0009配置，运行前需要修改各config里的配置项\n\n\u0009test/\u0009\u0009测试\n\nserver: 大致同check\n\nweb: 大致同check，多了gulp\n\nstatic: 静态资源文件\n\nupload: 上传资源文件\n```\n=============================================================================\n\n### 四、技术点：\n\n罗列本系统用到的一些有代表性的技术点，后续再分别详解。\n\n1. nginx: 作为分发服务器，域名服务分发、缓存、GZIP压缩、负载等\n\n2. nodejs: web、server、check系统，其中server在公司项目中常用更成熟的语言开发，如java\n\n3. express: web、server系统使用，是目前最常使用的nodejs框架，我也一直在使用\n\n4. koa: check系统使用，与express的主要区别在于异步回调的同步写法的实现，以解决回调金字塔的问题，回调金字塔很早就被问到过，不过当时认为这个不是问题，自身项目通常三层回调就可以解决了，并且函数分配合理，对易读性也不会有太大影响，不过本次开发过程中尝试使用了KOA，其对代码的易读、精简、组织上还是有很大的提升的，建议使用，需要一定的学习成本，另外其对一些已经开发第三方插件未全面支持，如redis、request等，需要再次包装同步调用机制，当然例举的这两个已经有了co-redis、koa-request。\n\n5. ejs: web系统使用，做页面渲染引擎，html在程序的语法上支持有限，jade成本会更高些，ejs在语法上和html一致，额外又支持数据语法。昨天和朋友讨论过这个问题，这也是很多初次接触分离的人疑问，为什么不直接使用html，数据全部用ajax，首先以我遇到的项目，全部走ajax是可行的，但有些页面变量据服务端配置动态获取会更好，并且在考虑SEO的时候数据更要直接渲染\n\n6. redis: server、web系统使用，缓存服务器，用于暂存一些状态数据，以便快速读写，如登录成功后由server将该用户数据写入到redis，并将对应的key通过web写入页面cookie，获取用户数据时，web都会先到redis里获取该用户是否登录。在对数据读取效率要求很高的情况下，也可以将数据库数据全部同步到redis，从redis读取，增删改操作数据库后，同步到redis.\n\n7. mongodb: check系统数据库，用于记录接口列表，简单易用，效率较高\n\n8. mysql: server系统数据库，区别于mongo，其在实际项目应用更广泛。\n\n9. reactJs: check系统页面，该系统是单页面，接口记录、验证抽象成组件，使用reactjs在开发及model维护上效率较高。\n\n10. webpack: check系统页面模块化、打包工具，配合reactJs\n\n11. requireJs: web系统页面模块化。\n\n12. log4js: web、server、check系统日志管理，服务端开发日志记录是必须的，常规的数据收发、异常错误跟踪、性能优化（如当某请求返回超过3秒就需要记录了）\n\n13. shouldJs、supertest、jasmine、coverage、karma: 共同组成单元测试方案\n\n14. gulp: web集成jshint、unglify等的自动打包工具\n\n15. nodemailer: server系统使用，用户注册成功后发送邮件到对方邮箱。\n    \n写了一篇文章：http://www.upopen.cn/blog/info?id=10020\n\n16. pm2: Nodejs进程管理器\n\n写了一篇文章：http://www.upopen.cn/blog/info?id=10021\n\n17. socket.io: web系统使用，在线用户所属数据改变时推送。\n\n18. 其它，如http协议、加密、静态化等。\n\n----\n\n### 五、其它\n\n系统在开发过程中，本着实用、多用的原则，推迟了开发周期，也尽量详细了解、记录了各软件、插件的使用。如mongodb的连接简单来讲就是\n```js\n   mongoose.connect( 'mongodb://' + config.host + '/' + config.db );\n```\n这也是常见demo的写法，即没有负载备份也没有验证，但实际使用时其至比项目程序的负载更重要，所以是应该写成 \n```js\n    var options = {\n\u0009  db: { native_parser: false },\n\u0009  server: { poolSize: 15 },\n\u0009  replset: { rs_name: 'rename' },\n\u0009  user: 'username',\n\u0009  pass: 'password'\n    }\n\n    mongoose.connect( 'mongodb://10.10.10.1:27017,10.10.10.2:27017,10.10.10.3:27017/updb', options );\n```\n对其它一些的插件也从实际使用过程中多了一些自己的理解，后续更新，希望会大家有所帮助","summary":"","title":"全栈开发技术栈---项目实践二 概述","__v":0}
{"_id":{"$oid":"57293a8b7297440b0aefad86"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"GIT是目前最先进的分布式版本控制系统\n分布式版本控制：记录项目文件任何改动，方便恢复至任一版本，方便多人协作\n\n官网：\u003chttp://git-scm.com/\u003e\n\n### 一、与SVN比较：\n1. 为了协作开发都需要有中央服务器，但其更侧重于分布式。本地获取代码后有了完整的代码库，可以做拉分支、提交等操作，即使没有网络也可以做除分享外的任何功能。有疑问说，不协作还能做什么？比如我们断网情况下改了十个问题，分别commit十个版本是合理的，有网络时再一次把十个版本做个提交push origin master，仍然记录的是十个版本。SVN无网络则无法commit，或建分支。\n\n2. 强大的分支功能\n\n3. 其它的就要使用的过程中慢慢体会\n\n所有版本库文件只能记录文本文件的改动，二进制文件是无法记录改变内容的如图片/视频，word也是二进制文件。\n\n用window的记事本编码也是有问题的，其在文本头做了改动，会导致乱码，建议用notepad++等专业编码器。\n\n### 二、安装：\n\n1、sudo apt-get install git     //安装成功后，执行git 查看所有命令\n初始化关联：\n\ngit init          //生成git可以管理的仓库，该目录下会多一个隐藏的 .git目录，即用来跟踪管理版本库。\n\ngit remote add origin https://github.com/xiaolulu/upopen.git     //关联远程库\n\n另外，在git上已经有了项目，直接clone，使用\n\ngit clone git@github.com/xiaolulu/demo.git     //拷贝远程库到本地，也可以用同上的add的https协议来关联，git默认是ssh协议，好处就是push时不用输密码，且速度更快\n\n### 三、操作： 可视化管理工具         \n\n```javascript\n    shell执行 gitk \n    git add readme          //将文件readme add到缓存区 git add * 添加所有\n    git commit -m \"this is a test commit\"          //将文件提交到 HEAD，保存一次快照，-m 注释\n    git push -u origin master          //将文件推到远端仓库，第一次推时加 -u 参数，将本地与远程关联，以后再推时不需要加 -u \n    另外还会用到\n    git status     //查看本地修改，显示哪些文件修改\n    git diff modify.txt     //会具体显示modify.txt修改了哪些内容\n    git log          //查看提交日志  git log --pretty=oneline     格式化查看\n    git log --pretty=oneline --abbrev-commit\n    git reset --head HEAD^ //回退上一版，HEAD^^ 前两版，HEAD～100，前100\n\n    git reset --head ******      //回退 或 向前，版本号可以通过前面的log查看\n    git reflog          //查看所有操作日志，log只能看回退的，向后的看不到，可以通过该命令查看\n    git checkout -- test.txt     //从缓存区恢复覆盖本地工作文件test.txt\n    git reset HEAD test.txt     //从HEAD区恢复覆盖缓存区工作文件\n\n    git rm test.txt                    //从工作区及缓存 git 删除，再git commit提交\n``` \n\n2、生成 ssh-key\n\nssh-keygen -t rsa -C \"jiangxiao2000@126.com\"\n\n3、配置全局\n\n```javascript\ngit config --global user.name \"xiaolulu\"\ngit config --global user.email \"jiangxiao.2000@163.com\"\ngit config --global color.ui true    \n``\n\n4、分支：\n\n```javascript\n    创建并切换分支：    git branch -b dev    //当前分支创建新分支\n    创建分支：     git branch dev\n    查看分支：     git branch\n    切换分支：     git checkout dev\n    合并指定分支到当前分支：git merge dev\n    删除分支：     git branch -d dev\n    git log --graph     //查看分支合并图\n```\n\n5、忽略文件：\n将需要忽略的文件名写入 .gitignore 文件，并提交至git。\n\n```javascript\n    # 注释\n    #指定过滤某种类型的文件：\n    *.zip\n    #指定过滤某个文件：\n    /mtk/do.c\n    #跟踪某个文件夹\n    !/plutommi/mmi\n    #跟踪某类文件\n    !*.c\n    #跟踪某个指定文件\n    !/plutommi/mmi/mmi_features.h\n```\n\n6、别名：\n\ngit config --global alias.ci commit     //配置commit的别名为ci，去除global则只对当前库有效\n\n配置是写在 .git/config里，\n\n7、标签：\n\n```javascript\n    git tag     v1.0     //对当前的commit创建标签\n    git tag                    //查看所有标签\n    git show v1.0          //查看指定标签\n    git tag v0.7     56958f     //给指定的commit id加标签\n    git tag -a v0.8     -m '这里是注释' 6f12cf     //加描述\n```\n\n```javascript\n    git push origin v0.1     //推送到远程\n    git push origin --tags      //推送全部\n    git tag -d v0.1     //删除tag\n    git push origin :refs/tags/v1.0     //删除远程\n```","summary":"GIT是目前最先进的分布式版本控制系统\n分布式版本控制：记录项目文件任何改动，方便恢复至任一版本，方便多人协作","title":"GIT的基础命令","__v":0}
{"_id":{"$oid":"57293af87297440b0aefad87"},"comment":0,"tags":"http","kind":"http","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"HTTPS就是安全版的HTTP，通过在HTTP和TCP之间加入TLS协议层，保证通信安全（TLS与SSL加强版）。\n\n基于TLS的加解密功能是内置于浏览器中，对数据进行加解密。\n\nHTTPS的主要作用有两点：\n\n1、建立一个信息安全通道，保证数据传输安全\n\n2、确认网站的真实性，使用https的网站，可以通过点击浏览器地址栏的锁标志查看认证信息。百度搜索已经是HTTPS了\n\n具体加密计算可参见 http://www.chinaz.com/web/2015/0505/403482.shtml。写的很详细\n\n采用https的服务器需从CA（常见的是VerSign） 申请一个用于证明服务器用途类型的证书，只有该证书用于对应的服务器时，客户端才信任此主机。\n\n与http的不同\n\n后者使用明文传输，如果截取了web浏览器与网站服务器之间传输的报文，可以直接读取其中的信息，不适合传输类如密码的敏感信息\n\n\nhttp风险     \n      \n1、窃听\n\n2、篡改\n\n3、冒充\n\nhttps 对策\n\n1、加密\n\n2、检验\n\n3、证书\n\n数据传输过程\n\n1、客户端 向 服务器发起https请求\n\n2、服务端 向 客户端 传送证书\n\n3、客户端解析证书，验证有较性，生成随机值，并用证书对随机值加密，形成加密数据\n\n4、客户将 加密数据 传送给服务器\n\n5、服务器 用 私钥 对 加密数据 解密，得到客户端生成的随机值\n\n6、服务器 会随机值 加密网站数据 并传送到客户端 \n\n7、客户端 私钥解密服务器端传来的数据","summary":"HTTPS就是安全版的HTTP，通过在HTTP和TCP之间加入TLS协议层，保证通信安全（TLS与SSL加强版）。","title":"https","__v":0}
{"_id":{"$oid":"57293b367297440b0aefad88"},"comment":0,"tags":"http","kind":"http","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、作用：\nCookie主要是由服务器生成的，发送给浏览器，保存在某个目录下的.txt文件，下次请求同一网站时，request.Header会带上该cookie给服务器，服务器据此信息记录该客户端，判断其权限信息等，最典型的是判断是否登录 及 用户操作统计\n\n在程序中，有会话的概念，从用户的维度划分，每个用户即一个会话，该用户只有访问、编辑属于自己的信息，购买的商品不能放到别人的购物车。而http是无状态的，cookies起到记录客户端状态的作用\n\n不同的服务器写入时，默认名称是不同的，\n\njsp写入时，cookies名为jsessionid\n\n因为每次http请求都会带上cookie，cookie内数据过大时，会影响速度\n\n### 二、查看\n对于开发者，可以通过chrome浏览器，的 Inspect element -- Resources -- Cookies 查看，并做删除操作\n\n也可以通过可以用 document.cookie\n\n保存英文使用ascii字符，一个英文内存占2个字节\n\n保存中文使用unicode字符，一个中文占4个字符\n\n### 三、属性\n\n```js\n{\n    name: Value,\n    expires: Date,                    //过期时间，当设置为0 或不设置时，关闭浏览器即清除cookie，设置为MAX_VALUE时将永久有效\n    path: Path,                         //不同path的cookie，也不能读取，根目录的cookie是可以共享的\n    domain: Domain_name   //设置cookie所属域名，不可跨域名，http不会带上不属于本站的cookie，二级域名也不行。\n    http: Boolean                    //是否使用于http，服务器设置此项，则本地不能读取，具有一定安全性。\n    secure: Boolean               //是否加密，https 和 ssl 中使用\n}\n```\n\n当设置了时间，cookie会保存.txt文件中，不设置则保存在内存中，关闭浏览器即失效\n\n### 四、操作\n\n服务端：nodejs为例\n\n读取：cookie服务器传递时放在 request.headers.cookie 里，多个cookie是用 ; 连接的字符串\n\n设置：response.setHeader(\"Set-Cookie\",cookies );\n\n要删除一个cookie，只要把其 expire 设置为0即可\n\n也不能修改cookie，要修改，只能新建一个同名的cookie，做覆盖\n\n页面端：\n\n建议使用jquery.cookies\n\njquery.cookies.set( name, value, options );\n\njquery.cookies.get( name )","summary":"","title":"cookie","__v":0}
{"_id":{"$oid":"57293b857297440b0aefad89"},"comment":0,"tags":"other","kind":"other","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"VI作为linux下最常用、方便的编辑器，有100+条的操作命令，但有些并不常用。非专业人员难以大量记住且容易混淆，这里罗列一些我目前常用的一些命令，足以完成日常操作。        \n\n打开：\n\n```js\n        vi filename                     //编辑文件，光标位于第一行\n        vi +n     filename             //编辑文件，光标位于第n行\n        vi + filename                 //编辑文件，光标位于最后一行\n        vi +/pattern filename    //编辑文件，光标在 pattern 所匹配的第一个位置\n        vi -r filename                 //如果上次编辑时崩溃了，该命令可以恢复\n        注：打开默认是指令模式，无法修改文本内容\n```\n\n浏览：\n\n```javascript\n        上下左右键                 控制移动光标移动\n        ctrl + f                         //下翻一屏\n        ctrl + b                         //上翻一屏\n        ngg                              // 5gg    跳到第5行\n        :set nu                         //显示行号\n```\n\n编辑：\n\n```javascript\n        i                                   // 光标前insert\n        I                                   //行首insert\n         a                                 //光标后 append\n        A                                 // 行未append\n        o                                 // 行下open新行\n        O                                 // 行上open新行\n        r                                   // 输入替换当前光标字母，只有效一次\n        R                                  // 输入替换当前光标字母，一直有效，直接esc \n        s                                  // 删除当前光标字母，并进入输入模式\n        S                                  // 删除当前光标所在行，并进入输入模式\n        x                                  // 删除光标后一位\n        X                                  // 删除光标前一位\n        dd                              // 删除当前行\n        ctrl + u                         // 撤消当前输入模式下所有输入内容\n        注：大写由 shift + 小写，效果更高，如 shift + s == S\n```\n\n搜索:\n\n```javascript\n        /pattern                     // 搜索 pattern\n        n                                // 搜索下移一个\n        shift+n                        // 搜索上移一个\n```\n\n替换：\n\n```javascript\n        : s /css/cssa/             // 将css 替换成 cssa\n        :%s /css/cssa            //  将css 全部替换成 cssa\n```\n\n保存退出：\n\n```javascript\n        :w                             // 保存不退出\n        :q                             // 不保存退出，若有修改退出不成功\n        :x                             //保存修改并退出\n        :q!                            // 不保存修改直接退出\n```\n\n注：VI下支持同shell终端同样的复制方式，ctrl + shift + c 复制，ctrl + shift + v   粘贴","summary":"","title":"linux下常用VI命令","__v":0}
{"_id":{"$oid":"5729412e7297440b0aefad8a"},"comment":0,"tags":"other","kind":"other","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、背景：\n\n随着的互联网技术的不断发展，浏览器逐渐成了集大成的CS客户端，页面功能在向系统级、软件级靠拢的趋势下，开发团队也需要一些软件工程的方法来开发WEB项目，如测试驱动、面向对象，而模块化编程更是成为一种急需应用的技术。\n    \n### 二、原因：\n\n为方便文件管理、增加复用，我们需要细化JS文件，每个文件负责单一职能，称之为模块，明确每个文件的职能，当交互功能较复杂时，引用的文件也越加庞大，此时我们就需要模块化管理。\n\n如我们编写一个模块组件Dialog.js，其依赖event.js / bootstrap.js / component.js，而event.js又依赖 base.js / core.js / el.js，bootstrap.js依赖 boot.js / under.js / almond.js，同理可能依赖更多的js，传统方法我们用到Dialog.js时实际上需要引用9个js，如下\n```html\n    \u003chtml\u003e\n    \u003cbody\u003e\n    ...\n     \u003cscript src=\"/public/base.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/public/core.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/public/el.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/public/boot.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/public/under.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/public/almond.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/module/event.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/module/bootstrap.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/module/component.js\"\u003e\u003c/script\u003e\n     \u003cscript src=\"/widget/dialog.js\"\u003e\u003c/script\u003e\n    \u003c/body\u003e\n    \u003c/html\u003e\n```\n我们将其细分，Dialog所依赖的每个js都负责了某一独立功能，分开便于其它组件复用，也利于学习理解。\n\n但将这9个js都到html里显示引用，工作量却非常可观，且不能弄错路径及加载顺序，若后续Dialog.js又需要多引用一个js，所有的项目都要手动增加，且这样依次同步加载下来会导致会占用浏览器线程，可能导致假死。\n   \n### 三、作用：\n\n模块化的作用就是解决上面提到的两点问题。\n\n1、实现js文件的异步加载，避免浏览器假死。\n \n2、管理模块之间的依赖，便于模块的维护\n    \n### 四、实现：\n\n模块化，就是把一个相对独立的功能，单独成一个文件，可输入指定依赖、输出指定的函数，供外界调用，其它都是内部的。这样即可方便不同的项目重复使用，也不会对其造成额外的影响。而既然要给不同的项目应用，特别像git上的模块是面向全球范围的，必然要形成可遵循的规范，开发者和使用者都有据可寻。\n\n目前通用javascript规范分为服务端（CommonJS），客户端（AMD / CMD）。\n\nCommonJS是针对javascript的服务端，一切模块都是通过require来同步加载调用， Nodejs采用的就是这个规范。\n```js\n    var module1 = require( 'module1'),\n          module2 = require( 'module2' );\n\n    function module3(){\n         ...\n     }\n    exports.module3 = module3;\n```\n注：通过require加载module1、2，操作后通过exports导致module3。\n\n\n这里我们主要讲客户端模块\n\n客户端与服务端的不同在于异步加载，之所以异步是因为CommonJS规则应用在服务端时，文件都是本地硬盘读取，不受限于网络，等待硬盘读取时间很短。而浏览器要考虑网速，若长时间等待会导致浏览器假死。\n\n引用形式如下图\n\n![amd pic](http://www.upopen.cn/upload/article/201509110855.jpg)\n    \n### 五、AMD。\n\n是\"Asynchronous Module Definition\"的缩写，意思就是\"异步模块定义\"，\n\n以require.js为代表，官网http://requirejs.org/ ，其形式主要是\n```js\n    =============main.js===================\n     \u003cscript src=\"js/require.js\" data-main=\"js/Dialog\"\u003e\u003c/script\u003e\n\n    ==============Dialog.js=======================\n     define( ['event', 'bootstrap', 'component' ], function( event, bootstrap, component ){\n          event.doSomthing();\n          bootstrap.doSomthing();\n           component.doSomthing();\n          var Dialog = function(){\n              ...\n          }\n          return {\n              Dialog: Dialog\n         }\n     });\n```\n     注：require接收两个参数，第一个参数是数组，含需加载的模块，第二个参数是回调，在模块加载成功后执行，且回调中的参数对应模块的加载顺序，这样主程序只需要加载一个JS文件，Dialog.js即可，其自会去加载event.js等文件，event.js再用同样的方式去加载base.js等，使用者无需考虑Dialog加载了多少引用，也无法担心其使用后会增减依赖。\n    \n### 六、CMD：\n\n以sea.js为代表，官网 http://seajs.org/docs/，理念为需要时再执行，即依赖就近\n```js \n     =============main.js===================\n     \u003cscript src=\"js/sea.js\"\u003e\u003c/script\u003e    \n    \u003cscript\u003eseajs.use(\"../static/hello/src/main\")\u003c/script\u003e\n\n    ==============Dialog.js=======================\n    define( function( require, exports, module ){\n        var event = require( 'event' );\n        event.doSomthing();\n        var bootstrap = require( 'bootstrap' );\n        bootstrap.doSomthing();\n        var component = require( 'component' );\n        component.doSomthing();\n        var Dialog = function(){\n             ...\n        }                    \n         exports.Dialog = Dialog;\n    })\n```\n    注：模块引用本身就在回调里，并且在使用前引用即可，所以sea.js强调的是懒加载，这也就是AMD和CMD之间唯一的区别。实际上，require.js也支持CMD的写法，不过依赖前置是其官方推荐。我最初因为对国产和玉伯的支持敬佩，使用了seajs，近来为了弄清楚AMD，项目全部用了requirejs，虽然网上及seajs官方对两种逻列了一些分别，但使用下来，感觉并无优劣。\n\n### 七、UMD\n\n因服务端与客户端对模块化加载方式的不同，就会人想做一个兼容的模块UMD（Universal Module Definition），来解决跨平台的问题。但对于我们开发者来讲实则没有什么意义，也不深入了。\n    \n### 八、require.js使用：\n```js\n    require.config({\n          baseUrl: 'module/js',     //配置path下的统一目的，以便path中不会分别配置\n          path: {                              //配置module路径，以便引用时不用写全路径\n              module1: 'module1',\n              module2: 'module2',\n              module3: 'http://www.site.com/module3'     //若引用的是第三方，可以全部全路径\n         },\n          shim: {     //对不符合AMD规则的模块引用\n              'underscore': {\n                   exports: '_'          //配置其原对外接口\n              },\n              'backbone': {\n                   deps: ['underscore', 'jquery'],     //配置其依赖项\n                   exports: 'Backbone'\n             }\n         }\n     });\n\n    define( ['module1', 'module2' ], function( module1, module2 ){\n          module1.doSomthing();\n          module2.doSomthing();\n          function module3(){\n              ...\n         }\n          return {\n              module3: module3\n         }\n     })\n```\n### 九、require.js时间戳\n\nrequire.js没有找到可配置时间戳，可修改require.js源文件中的load方法 \n```js\n     load: function (id, url) {\n        url += '?' + timestamp;     \n        req.load(context, id, url);     \n    },\n```    \n新增 url += '?' + timestamp; 这一处语句，即为url添加timestamp，timestamp可以另外通过配置文件配置。我使用nodejs开发，在服务端的config文件配置 timestamp: '2015091112'，将其插入到客户端 ejs文件内\n```js\n     \u003cscript\u003e\n         var timestamp = '\u003c%= timestamp %\u003e';\n     \u003c/script\u003e\n```\n     这样即可在 require.js 文件内调用。\n\n### 十、require.js合并：\n官网提供了r.js用于该模块化的打包  https://github.com/jrburke/r.js\nr.js是将通过require.js引用的模块化文件都合并到一个文件里，以减少文件加载数量。\n项目参考 \u003chttps://github.com/xiaolulu/mynodejs.git\u003e\n首先下载r.js，可以到静态文件根目录，新建build.js用于配置r.js，常见的配置如下\n```js    \n    build.js\n\n    ({ \n        appDir: './', //项目根目录，给后面的baseUrl做参考;非必要项;默认为与r.js平级目录\n        dir: './min', //压缩后的文件的输出目录 \n        baseUrl: './', //模块相对目录，与后面的paths配置使用\n        modules: [ \n                { name:'login'},\n                { name: 'register' },\n                { name: 'center' }\n        ], \n        fileExclusionRegExp: /^(r|build)\\.js|.*\\.scss$/, //过滤文件不压缩\n        optimizeCss: 'standard', //css的标准方式\n        optimize: 'uglify', //设置是否压缩;uglify(压缩格式)|none(只合并不压缩)\n        removeCombined: true, //设置移除压缩后的文件\n        paths: { //设置模块别名，方便引用，压缩后require.js引用的模块路径就在这里定义的，不是require.config里的\n                md5: 'core/js/md5',\n                validate: 'widget/validate/validate',\n                all: 'public/js/all',\n                login: 'module/issue/login/login',\n                register: 'module/issue/register/register',\n                center: 'module/user/center/center'\n        }\n    })\n```\nshell执行 node r.js -o build.js\n    \n#### 十一、almond:\n\n合并后所有原通过模块化加载的文件都已经在一个文件里了，已经不需要require.js的大部分功能，但因合并后代码里还是有require / define的函数定义，这里命令解析还是要有的，所以就有了almond.js（约15KB），其保留了require.js（约80KB）的子集，但不支持模块化加载，即对已经合并后的模块解析可以使用，减少代码量。\n\n不过，其理念是好的，但实现方案还待改进，其执行后就会almond.js与前面合并后过的业务JS合并成一个文件，直接用 src来引用，意味着每个页面都需要的 almond.js将无法缓存，所以当业务JS超过五个时，这个方案将没有意义，有兴趣可以自行到git上学习，这里不在讲述\u003chttps://github.com/jrburke/almond\u003e\n\n#### 全栈工程新Q群：435485569\n#### 相关文件可参考 \u003chttp://www.upopen.cn\u003e","summary":"","title":"JS模块化编程总结_待续","__v":0}
{"_id":{"$oid":"572941c47297440b0aefad8b"},"comment":0,"tags":"http","kind":"http","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"从页面、运维、服务三方面整理这个问题\n\n***\n\n### 一、页面端\n\n#### 1、优化html / css / js写法，此处和技术能力及开发习惯有关\n\n\u003e如：\n\n\u003ea、尽量减少DOM数量及层级，会增加dom计算量。\n\n\u003eb、重绘对页面绘制效率影响较大，而重绘通常是因流式布局中dom的大小变化而造成的其后dom位置改变，所以对会影响DOM的样式前置加载。\n\n\u003ec、src通过属性预先设置宽高，图片通常是置后显示的，提前定义大小可以减少重绘。\n\n\u003ed、css避免使用通配符\n\n\u003ee、css避免使用dom查找，如 ul li{}，而直接使用cass名，如.classLi{}\n\n\u003ef、css避免使用多级查找如 ，div span ul li{}，直接用 .divSpanUlLi{}。因为css查找是自右至左的\n\n\u003eg、css避免使用伪类，ie浏览器对此类样式渲染很慢\n\n\u003eh、head中指明编码格式，浏览器每次获取数据，通常只能缓存1KB数据，若未能找到编码定义，则会用默认编码，后面再找到定义则需重新渲染。\n\n\u003eg、当页面较长时，非当前屏的图片延后加载。\n\n\u003eh、JS渲染dom时，在缓存内组装好且加好event，再一次性插入到页面。对有可能再次操作的dom，渲染前就在缓存里保留指针，以便再次访问时不需要到页面DOM里查找，该写对开发习惯有较高的要求。\n\n\u003ei、独立将css / js 独立成文件，独立不仅会使页面代码更加清晰，其也会被浏览器缓存。\n\n\u003eh、引用CSS时用link，不要后@import，后者不会被缓存\n\n\u003e注：上面有些建议与实际开发效率相违背，不要教条，视情况采纳。\n\n#### 2、资源加载顺序\n\n\u003ea、原则上影响页面初始html加载显示的都后置加载。\n\n\u003eb、但若影响页面初建显示的css文件需放head里加载，以便不会使页面加载产生错乱，并且该部分的CSS后置会导致页面绘制回流，影响速度。CSS中不要使用expressions形式。\n\n\u003ec、不会影响初始效果的css放页面底，如弹框等组件的CSS，通常不会初始显示，即使显示也是在页面加载完成，经过一些JS逻辑执行后。\n\n\u003ed、JS文件放页面底部加载，JS使用模块化框架如requirejs，其不能提高速度，但能使代码更清晰，便于管控\n\n#### 3、减少http请求\n\n\u003e使用uglify.js类框架合并、压缩JS / CSS文件，图片使用css sprites，对于一些常用的小图标用 inline images 及 iconfont\n\n#### 4、Ajax\n\n\u003ea、对数据库查询量较大的数据使用异步ajax，减少返回等待时间。\n\n\u003eb、数据请求尽量用get请求，其将请求附在url上， 服务端一次就可以从request.header中收到。post请求是在header之后在另行发送的。显然前者速度会更快。\n\n\u003ec、另外get请求可以被缓存，对于数据较稳定的请求可以缓存ajax，但需要慎重，禁用缓存 $.ajaxSetup( { cache: false } );\n\n#### 5、减少cookie，每次http请求都会自动将cookie带到后台，增加传输文件量。比较极致的方案，是静态资源跨域名存放，跨域名请求时不会带cookie，但JS文件会产生跨域的问题。另外浏览器对cookie大小限制在4kb以内。\n\n***\n\n### 二、运维\n\n#### 1、缓存\n\n\u003e设置缓存静态资源，js / css /imgs等，以便用户再次访问时，可以读取本地文件。不过要设置良好的更新机制，可以设置cache的 expires 到指定日期，但因站点信息的变动时间不确定，为避免服务器资源已修改，而客户端仍用旧文件的情况，可以通过为静态资源文件加时间戳的形式。\n\n#### 2、Gzip压缩\n\n\u003enginx开启Gzip压缩，通过设置压缩比，可明显的减小数据传送\n\n#### 3、CDN技术，部署成本较大，现在已经有很多成熟的CDN服务商，会依据请求方地址，就近加载。\n\n#### 4、静态资源多个域名部署\n\n\u003e浏览器对同一域名的并发请求通常为2-4个，静态资源部署在不同域名的服务器上增加并发数。\n\n***\n\n### 三、服务端\n\n#####1、对可能会出现的并发接口提供组合，如某模块显示资源需从不同的表多次分开请求获取，对于此类，应请求组合接口，以便一次请求即可获取需要的数据\n    \n***\n\n### 四、手机\n\n#### 1、单个文件小于25K，部分手机对超过25K的文件不会缓存","summary":"","title":"网页加载性能优化","__v":0}
{"_id":{"$oid":"572942297297440b0aefad8c"},"comment":0,"tags":"http","kind":"http","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、QQ安装：\n\n**下载**\n\n地址：\u003chttp://yun.baidu.com/share/link?uk=2147599678\u0026shareid=3052711415\u0026qrfrom=1\u0026qrtype=\u003e\n压缩包内有\n\n...fonts-wqy-microhei_0.2.0-beta-2_all.deb\n\n...ttf-wqy-microhei_0.2.0-beta-2_all.deb\n\n...wine-qqintl_0.1.3-2_i386.deb\n\n**安装：**\n\n    1、sudo dpkg -i fonts-wqy-microhei_0.2.0-beta-2_all.deb\n\n    2、sudo dpkg -i ttf-wqy-microhei_0.2.0-beta-2_all.deb\n\n    3、sudo dpkg -i wine-qqintl_0.1.3-2_i386.deb\n\n    注：执行3时，有时因缺少依赖而报错，可执行 sudo apt-get install -f 安装依赖后再执行 3\n\n安装后启动图标有时不会显示在桌面上，可以通过搜索QQ程序启动。","summary":"","title":"Ubuntu Soft","__v":0}
{"_id":{"$oid":"572942db7297440b0aefad8d"},"comment":0,"tags":"http","kind":"http","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n以\u003chttp://www.upopen.cn/article/info?id=559291b3f0e6e0665b000001\u003e 方式安装的双系统，卸载时需要先删除ubuntu的启动引导，再清空其盘符即可，操作很简单。\n\n### 二、准备\nmbrfix软件\n\n### 三、删除配置\n#### 1、将下载的MbrFix.exe，放到C盘根目录\n\n#### 2、打开命令行，快捷键为 win + r，切换到C盘根目录，执行 Mbrfix /drive 0 fixmbr，即完成启动引导修改\n\n![alt text](http://www.upopen.cn/upload/mbrfix/mbrfix1.png)\n\n#### 3、有些电脑出提示拒绝，如图\n\n![alt text](http://www.upopen.cn/upload/mbrfix/mbrfix2.png)\n\n#### 4、通过桌面找到放在C盘下的MbrFix.exe，右键 - 属性 - 兼容性，勾选 特权等级，以管理员身份运行，再执行第2步即可\n\n![alt text](http://www.upopen.cn/upload/mbrfix/mbrfix3.png)\n\n#### 5、通过桌面打开 计算机 - 管理 - 磁盘管理，空磁盘，右键选择 删除卷 即可完成\n\n![alt text](http://www.upopen.cn/upload/mbrfix/3.jpg)","summary":"","title":"win7下卸载ubuntu系统","__v":0}
{"_id":{"$oid":"572943717297440b0aefad8e"},"comment":0,"tags":"http","kind":"http","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、ubuntu是较适合个人开发使用的linux系统，安装可以选择全系统、虚假机、双系统。\n    \n全系统安装：使用时会多有不便，主要表现为软件不支持如 ps / qq /flash\n\n虚拟机安装：可以用来练手，但如果作为开发平台，其功能较弱\n\n双系统安装：是折中方案，使用起来和全系统没有差别，也方便切换\n\n### 二、准备：安装共需约20分钟\n\n空U盘      - 制作系统引导盘\n\nUltralSO  - 制作系统引导盘软件\n\nubuntu系统 - 32/64对应自己的系统 http://cn.ubuntu.com/download\n\n### 三、从硬盘里分出空盘给ubuntu\n\n#### 1、打开 计算机 - 管理 - 磁盘管理，选择可以用来划空盘的硬盘，右键选择 “压缩卷”\n\n![alt text][logo1]\n\n[logo1]: http://www.upopen.cn/assets/upload/ubuntu/1.jpg \"Logo Title Text 2\"\n\n\n#### 2、输入压缩空间，大小主要考虑将来开发使用，以100GB为例，执行压缩\n\n![alt text][logo2]\n\n[logo2]: http://www.upopen.cn/assets/upload/ubuntu/2.jpg \"Logo Title Text 2\"\n\n#### 3、如图，即压缩成功100GB的可用空间\n\n![alt text][logo3]\n\n[logo3]: http://www.upopen.cn/assets/upload/ubuntu/3.jpg \"Logo Title Text 2\"\n\n### 四、制作引导光盘\n\n#### 1、插入空U盘，启动UltralSO\n\n![alt text][logo4]\n\n[logo4]: http://www.upopen.cn/assets/upload/uiso/1.jpg \"Logo Title Text 2\"\n\n#### 2、点击 打开，选择打开ubuntu.iso包\n\n![alt text][logo5]\n\n[logo5]: http://www.upopen.cn/assets/upload/uiso/2.jpg \"Logo Title Text 2\"\n\n#### 3、点击 启动 - 写入硬盘映像\n\n![alt text][logo6]\n\n[logo6]: http://www.upopen.cn/assets/upload/uiso/3.jpg \"Logo Title Text 2\"\n\n#### 4、写入方式为 USB-ZIP+，点击写入\n\n![alt text][logo7]\n\n[logo7]: http://www.upopen.cn/assets/upload/uiso/3.jpg \"Logo Title Text 2\"\n\n#### 5、刻录成功\n\n![alt text][logo8]\n\n[logo8]: http://www.upopen.cn/assets/upload/uiso/5.jpg \"Logo Title Text 2\"\n\n#### 6、查看磁盘盘符，可以到U盘变化\n\n![alt text][logo9]\n\n[logo9]: http://www.upopen.cn/assets/upload/uiso/6.jpg \"Logo Title Text 2\"\n\n### 五、安装ubuntu\n\n#### 1、重启计算机，开启即按F12，打开选择启动设备面板，选择USB\n\n![alt text][logo10]\n\n[logo10]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-1.jpg \"Logo Title Text 2\"\n\n#### 2、继续启动，看到如下画面，不同版本系统会略有不同\n\n![alt text][logo11]\n\n[logo11]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-20.jpg \"Logo Title Text 2\"\n\n#### 3、进入ubuntu安装界面，视情况选择中英文，建议选择英文，更适合开发，会多一定的学习成本\n\n![alt text][logo12]\n\n[logo12]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-3.jpg \"Logo Title Text 2\"\n\n#### 4、Wireless，选择不连接网络，安装时用不到，点击继续\n\n![alt text][logo13]\n\n[logo13]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-4.jpg \"Logo Title Text 2\"\n\n#### 5、Preparing to install Ubuntu Kylin，下面两个复选框不需要勾选，点击继续\n\n![alt text][logo14]\n\n[logo14]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-5.jpg \"Logo Title Text 2\"\n\n#### 6、Installation type，选择 something else，自己分盘\n\n![alt text][logo15]\n\n[logo15]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-6.jpg \"Logo Title Text 2\"\n\n#### 7、Installation type，选择 free space，即我们第三步时划出的盘，点击+，增加划盘\n\n![alt text][logo16]\n\n[logo16]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-8.jpg \"Logo Title Text 2\"\n\n#### 8、划盘1，配置如图，常规20000MB，根目录盘\n\n![alt text][logo17]\n\n[logo17]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-9.jpg \"Logo Title Text 2\"\n\n#### 9、划盘2，配置如图，常规2048MB，内存\n\n![alt text][logo18]\n\n[logo18]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-10.jpg \"Logo Title Text 2\"\n\n#### 10、划盘3，配置如图，常规200MB\n\n![alt text][logo19]\n\n[logo19]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-11.jpg \"Logo Title Text 2\"\n\n#### 11、划盘4，配置如图，其它所有空间，作为我们日常使用盘\n\n![alt text][logo20]\n\n[logo20]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-12.jpg \"Logo Title Text 2\"\n\n#### 12、划好盘后，其它默认，Device for boot .. 选择 /dev/sda/ ATA WDC...，指定从ubuntu启动win7\n\n![alt text][logo21]\n\n[logo21]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-13.jpg \"Logo Title Text 2\"\n\n#### 13、点击安装，弹出框，点击继续\n\n![alt text][logo22]\n\n[logo22]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-14.jpg \"Logo Title Text 2\"\n\n#### 14、选择时区，上海\n\n![alt text][logo23]\n\n[logo23]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-15.jpg \"Logo Title Text 2\"\n\n\n#### 15、选择语言，英文\n\n![alt text][logo24]\n\n[logo24]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-16.jpg \"Logo Title Text 2\"\n\n#### 16、设置主机名及密码，随意，不过 your computer's name尽量短些，后面执行shell命令时，其会占位置\n\n![alt text][logo25]\n\n[logo25]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-17.jpg \"Logo Title Text 2\"\n\n#### 17、执行安装\n\n![alt text][logo26]\n\n[logo26]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-18.jpg \"Logo Title Text 2\"\n\n#### 18、安装成功后，重启\n\n![alt text][logo27]\n\n[logo27]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-19.jpg \"Logo Title Text 2\"\n\n#### 19、启动后，提示选择启动哪种系统，默认第一个是ubuntu，最后一个是win7\n\n![alt text][logo28]\n\n[logo28]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-21.jpg \"Logo Title Text 2\"\n\n\n#### 20、登录页面 \n\n![alt text][logo29]\n\n[logo29]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-22.jpg \"Logo Title Text 2\"\n\n#### 21、系统桌面，和ios类似，同为类unix系统\n\n![alt text][logo30]\n\n[logo30]: http://www.upopen.cn/assets/upload/ubuntuInstall/2015-06-29-2.jpg \"Logo Title Text 2\"\n\n### 六、系统卸载，见教程...\n### 七、系统使用，见教程...","summary":"","title":"win7下安装ubuntu双系统图文教程","__v":0}
{"_id":{"$oid":"572943c07297440b0aefad8f"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"通过学习、应用nodejs推动了公司的前后端分离，写了几篇分享，有网友反馈说这个技术栈拉的长了，如何去学习。\n\n技术学习无非就是学一点，用一点，如此反复而已，不是看一点教程照着做些demo就可以的，何况很多新技术的教程demo都是彼此复制的。\n\n技术要学以致用，就是需要应用到实际项目才能融会贯通，但公司项目往往不能满足学习实践的要求，这也是面试者常用会抱怨平台不足的问题，大部分人都会遇到这种情况，其实平台永远都不足的，需要自己去想办法解决。可以模拟一个较实际的项目，将技术加以应用，提供有说服力的数据，分析其优劣，再向公司推广，这样才是可持续的、互利的，我就是这样在项目中推进了前后端分离实践，部分系统全部用nodejs+mongodb来完成。\n\n前端做了四年半了，在思考进一步完善技术栈，近来又总结了些技术，准备把我的站点\u003cwww.upopen.cn\u003e 重构下，尽量运用所学技术，如若效果不错，再运用到公司项目里。\n\n---\n\n站点规划如下：\n\n功能：\n用户注册、登录、管理\n文章分类、发布、编辑、静态化、评论\n后台管理\n...\n\n客户端：\nPC端\n微信端 - 新增会员绑定\nAPP端 - react native，涵盖 IOS   / android\n\n整体采用前后端分离形式：\n接收、分析客户端请求的前端服务\n操作数据库的后端服务\n后端也是用nodejs实现，这样分离是为了项目中的实际应用。\n\n预计会用到的技术点：\n\n开发系统：ubuntu\n静态服务器：nginx\n数据库：mongodb\n缓存服务器：redis\n版本控制器：git\n开发语言：nodejs\n\n页面端：\n组件开发：react.js\n模块加载：webpack\n响应式：bootstrap\n编辑器：markdown\n\n服务端：\nhttp框架：express\n模块引擎：ejs\n调用工具：inspector\n日志：log4js\n邮件：node-mailer\n实时通讯：socket.io\n单元测试：\n    should.js - 断言模块\n    supertest - HTTP测试\n    mocha - 测试插件\n    istanbul - 覆盖率\n    karma - 自动化\n语法检测：jshint\n代码压缩：uglify\n项目构建：gulp\n项目监听：node-dev\n进程守护：pm2\n...\n\n安全机制：防止 XSS / CSRF攻击，做数据加密，用户信息用https协议传输\n\n实践网页最佳性能加载","summary":"","title":"全栈开发技术栈---项目实践一","__v":0}
{"_id":{"$oid":"572944677297440b0aefad90"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\nNodejs使用有些日子了，近来再回顾下其API、多使用新特性，以期有更高层次的掌握，本次API的总结区别于单纯对英文版的汉化，会多做些扩展和自己的理解，希望对大家有所帮助，先从最核心的Events开始\n\nNodejs的Events实现了一种观察者模式，其支持了Nodejs的核心机制，且http / fs / mongoose等都继承了Events，可以添加监听事件。这种设计模式在客户端的组件编程思想里经常会用到，我们先简单了解下该模式。\n\n首次接触 观察者模式是在Extjs框架的 Ext.util.observable源码，那时刚接触js，感觉这种模式很强大，也是我最早接触到的设计模式，后来在 underscore.js 源码里也有看到，且后者实现更简捷、优雅，我编写组件时也基本是按照这种思想。\n\n观察者模式就是为某一对象添加一监听事件，如on('show', callback)，由该对象在符合条件如show时自行触发，浏览器本身已经为dom实现了监听机制。\n\n如我们为input添加keyup监听，目的是为了输出其value\n```js\n    $( 'input' ).on( 'keyup', function(){\n          console.log( this.value );\n    } );\n```\n这样输入内容时会自行在日志中输出其value。\n\n但我们自己做一个组件如Dialog，如何监听最常用的show / hide事件呢?\n\n初级的做法是实例化时直接将回调配置进去，如\n```js\n    var dialog = new Dialog({\n        content: '这里是弹出框的内容',\n        show: function(){\n            console.log( '当弹框时输出此段内容' );\n        }\n    });\n```\n这样也可以用，不过显然不够灵活，如何将dialog做的像input那样可随时添加事件呢。下面是一个极简的实现\n\n####二、观察者模式实现\n\n首先实现Events对象，这里提供基础的监听on和触发emit，事件是以json形式压栈在对象的_events里\n```js\n    var Events = {\n        on: function( name, callback){\n            this._events = this._events || {};\n            this._events[ name ] = this._events[ name ] || [];\n            this._events[ name ].push( callback );\n        },\n        emit: function( name ){\n            this._events = this._events || {};\n            var args = Array.prototype.slice.call( arguments, 1 ),\n                  me = this;\n            if( this._events[ name ] ){\n                $.each( this._events[ name ], function( k, v ){\n                    v.call( me, args );\n                } )\n            }\n        }     \n    }\n```\n再抽象一个函数用于为对象复制属性\n```js\n    function extend( source ){\n        var args = Array.prototype.slice.call( arguments, 1 );\n        for( var i = 0, parent; parent = args[i]; i++ ){\n            for( var prop in parent ){\n                source[ prop ] = parent[ prop ];\n            }\n        }\n    }\n```\n实现一个Dialog，\n仅实现创建; method: show / hide; event: show / hide;\n\n看效果时，加上这段样式\n```css\n    .dialog{\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        margin: -50px 0 0 -100px;\n        width: 200px;\n        height: 120px;\n        background: #fff;\n        border: 5px solid #afafaf;\n    }\n```\n实现组件\n```js\n    var Dialog = function( config ){\n        this.config = config;\n        this.init( this.config );\n    };\n```\n扩展属性\n```js\n    extend( Dialog.prototype, {\n\n        init: function( config ){\n            this.render( config )\n        },\n\n        render: function( config ){\n            this.el = $( '\u003cdiv\u003e' ).addClass( 'dialog' );\n            this.el.html( config.content );\n            $( 'body' ).append( this.el );\n        },\n\n        show: function( param ){\n            this.el.fadeIn();\n            this.emit( 'show', param );\n        },\n\n        hide: function( param ){\n            this.el.fadeOut();\n            this.emit( 'hide', param );\n        }\n\n    }, Events );\n```\n生成实例，并为其添加三个show及hide监听事件\n```js\n    var dialog = window.dialog = new Dialog({\n        content: 'dialog one'\n    });\n\n    dialog.on( 'show', function( txt ){\n        console.log( 'dialog show one ' + txt );\n    } );\n\n    //do something\n\n    dialog.on( 'show', function( txt ){\n        console.log( 'dialog show two ' + txt );\n    } );\n\n    //do something\n\n    dialog.on( 'show', function( txt ){\n        console.log( 'dialog show three ' + txt );\n    } );\n\n    //do something\n\n    dialog.on( 'hide', function( txt ){\n        console.log( 'dialog hide one ' + txt );\n    } );\n\n    //do something\n\n    dialog.on( 'hide', function( txt ){\n        console.log( 'dialog hide two ' + txt );\n    } );\n\n    //do something\n\n    dialog.on( 'hide', function( txt ){\n        console.log( 'dialog hide three ' + txt );\n    } );\n```\n我们分六次添加了六个不同的show事件和hide事件。\n当执行 dialog.show() 时就会输出三条对应的日志。添加的事件保存在 dialog._events里，如图\n\n![pic](http://www.upopen.cn/upload/nodejs/event.jpg)\n\n添加的三个show都输出成功，事件保存在_events属性里\n\nnodejs Events也是实现了这一过程。\n\n### 三、结构\n```js\n    var Events = require( 'events' );\n    console.log( Events );\n    /*\n    输出如下数据，可以看出 Events指向其EventEmiter\n    { [Function: EventEmitter]\n        EventEmitter: [Circular],\n        usingDomains: [Getter/Setter],\n        defaultMaxListeners: 10,\n        init: [Function],\n        listenerCount: [Function] }\n    */\n\n    var myEmitter = new Events();\n    console.log( myEmitter );\n    /*\n    { domain: null,\n        _events: {},     //可以看到实例本身也有_events属性，添加的监听的事件就保存在这里\n        _maxListeners: undefined}\n    */\n\n    console.log( myEmitter.__proto__ );\n    /*\n    { domain: undefined,\n        _events: undefined,\n        _maxListeners: undefined,\n        setMaxListeners: [Function: setMaxListeners],\n        emit: [Function: emit],\n        addListener: [Function: addListener],\n        on: [Function: addListener],\n        once: [Function: once],\n        removeListener: [Function: removeListener],\n        removeAllListeners: [Function: removeAllListeners],\n        listeners: [Function: listeners] }\n    */\n\n    myEmitter.on( 'show', function( txt ){ console.log( 'one ' + txt )})\n    myEmitter.on( 'show', function( txt ){ console.log( 'tow ' + txt )})\n    myEmitter.on( 'hide', function( txt ){ console.log( 'one ' + txt )})\n    myEmitter.emit( 'show', 'show' );\n    myEmitter.setMaxListeners( 10 );\n    console.log( myEmitter );\n    /*\n    { domain: null,\n        _events: { show: [ [Function], [Function] ], hide: [Function] }, //添加后的事情，以json形式存放\n        _maxListeners: 10 }\n    */\n```\n####四、API\n\n其提供的method有on，是addListener的简写都是为实例添加监听事件，其它属性也都顾名思义，就简单说明下\n```js\n    property\n    _events: undefined,     //以压栈形式存放on进来的事件\n    _maxListeners: undefined   //设置最大监听数，超出提warn\n\n    ----------------------------------------------------------------------------------------------------------------\n\n    method\n    setMaxListeners: [Function: setMaxListeners],  \n    /*设置私有属性_maxListeners的值，默认Events会在当某监听事件多于10个时发现警告(见上面Events.defaultMaxListeners)，以防止内存泄露，如\n    (node) warning: possible EventEmitter memory leak detected. 11 show listeners added. Use emitter.setMaxListeners() to increase limit.\n    但这只是个友好的提醒，可以通过设置最大监听数来规避这个问题\n    myEmitter.setMaxListeners( 20 );\n    */\n\n    emit: [Function: emit],\n     /*触发监听事件\n    emitter.emit( event, [arg1], [arg2], ...  )\n    如myEmitter.on( 'show', 'prompt content'  );\n     参数1为事件名，参数二供on回调里的参数\n     */\n\n    addListener: [Function: addListener],\n     /*\n    添加监听事件\n    emitter.addListener( event, listener );\n    如 myEmitter.addListener( 'show', function( txt ){ console.log( txt ) } );\n    参数一是事件名，参数二是对应的回调，回调里的参数就是 emit里的arguments.prototype.slice.call(1);\n     */\n\n    on: [Function: addListener],\n     /*\n    是addListener简写\n     */\n\n    once: [Function: once],\n     /*\n    作用同 on，不过emit一次后就失效了\n    emitter.once( event, listener );\n    如 myEmitter.once( 'show', function( txt ){ console.log( txt ) } );\n    当myEmitter.emit执行第二次时没有输出\n     */\n\n    removeListener: [Function: removeListener],\n     /*\n    移除指定事件的指定回调，此时回调不能再用匿名函数。\n    emitter.removeListener( event, listener );\n    如  \n    function show( txt ){ console.log( txt ) };\n    myEmitter.on( 'show', show );\n    console.log( myEmitter._events ); \n    // { show: [ Function: show ] }\n    myEmitter.removeListener( 'show', show );   \n     console.log( myEmitter._events ); \n    // {}\n     */\n\n    removeAllListeners: [Function: removeAllListeners],\n     /*\n     删除指定事件的所有回调\n     emitter.removeAllListeners( [ event ] );\n     如 \n        myEmitter.removeAllListeners( 'show' );     //删除所有show监听\n        myEmitter.removeAllListeners();     //删除所有监听\n     */\n\n    listeners: [Function: listeners]\n    /*\n    查看指定监听\n    emitter.listeners( event );\n    如 myEmitter.listeners( 'show' ); //返回一个数组\n    同我们前面使用的 myEmitter._events[ 'show' ]\n    */\n\n    另外Events类本身提供了一个方法\n    Events.listenerCount( emitter, event ); 获取指定实例下指定监听数\n    如 Event.listenerCount( myEmitter, 'show' )\n\n    -----------------------------------------------------------------------------------------------\n\n    还有两个event\n    newListener /  remoteListener，分别应用于为实例添加（ on / once ）和删除( removeListener ) 操作。\n    emitter.on( event, listener );\n    emitter.on( 'newListener', function( event, listener ){\n        console.log( emitter.listeners( 'show' ) );     //注意，此时监听还并没有添加到 emitter.listeners\n        console.log( arguments );    \n     });\n    \n     emitter.on( 'removeListener', function(){\n        console.log( emitter.listeners( 'show' ) );\n        console.log( arguments );\n     })\n```\n####五、应用\n\n使用Events，通常就直接实例化即可，如上面API部分所例\n\n不过，如果我们在nodejs端也实现了一个组件，如前面的Dialog，如何让Dialog也具备Events的功能呢？可以用Extjs实现的 extend方案\n\n创建Dialog构建器\n```js\n    var Dialog = function(){\n        //do something\n    }\n\n    //抽象apply函数，提供属性的深度复制，同上面的extend\n    function apply( source ){\n        var args = Array.prototype.slice.call( arguments, 1 );\n        for( var i = 0, parent; parent = args[i]; i++ ){\n            for( var prop in parent ){\n                source[ prop ] = parent[ prop ];\n            }\n        }\n    }\n\n    //抽象extend函数，用于实现继承\n    var extend = function(){\n        // inline overrides\n        var io = function(o){\n            for(var m in o){\n                this[m] = o[m];\n            }\n        };\n        var oc = Object.prototype.constructor;\n\n        return function(sb, sp, overrides){\n            if(typeof sp == 'object'){\n                overrides = sp;\n                sp = sb;\n                sb = overrides.constructor != oc ? overrides.constructor : function(){sp.apply(this, arguments);};\n            }\n            var F = function(){},\n                sbp,\n                spp = sp.prototype;\n\n            F.prototype = spp;\n            sbp = sb.prototype = new F();\n            sbp.constructor=sb;\n            sb.superclass=spp;\n            if(spp.constructor == oc){\n                spp.constructor=sp;\n            }\n            sb.override = function(o){\n               apply(sb, o);\n            };\n            sbp.superclass = sbp.supr = (function(){\n                return spp;\n            });\n            sbp.override = io;\n            apply(sb, overrides);\n            sb.extend = function(o){return extend(sb, o);};\n            return sb;\n        };\n    }();\n\n    //将Events属性继承给Dialog\n    Dialog = extend( Dialog, Events );\n\n    //为Dialog新增 method show，其内触发 event show\n    Dialog.prototype.show = function( txt ){\n        this.emit( 'show', txt );\n    }\n\n    var dialog = new Dialog();\n\n    //添加监听事件show\n    dialog.on( 'show', function(txt){ console.log( txt )});\n\n    //执行method show时，就会触发其内定义的show events，输出 this is show\n    dialog.show( 'this is show' );\n```\n这样就为一个组件实现了Events机制，当调用method时，会触发event\n\n####六、总结\n\nnodejs提供了很好的监听机制，并且也应用在其所有模块，其支持了nodejs最特色的I/O模式，如我们启动http服务时会监听其 connect / close，http.request时会监听 data / end等，了解监听机制对学习理解nodejs的基础，也对提提升编程思想有益。","summary":"","title":"Nodejs API-Events 谈观察者模式","__v":0}
{"_id":{"$oid":"572944d07297440b0aefad91"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n\n*   对nodejs有了些准备，希望多了解些后端知识，恰逢公司项目调整，分析了前后端分离的优劣，也做了一个完整的demo演示，同事都觉得靠谱，用了两个版本的时间，将公司主站项目用nodejs实现了前后端分离，在此和大家分享下，以求共同进步。案例参见 http://www.upopen.cn\n \n### 二、为何做分离\n\n*   1、开发体系：架构体系决定了后端重于前端，前端做好静态页后，要转为php或vm等，开发要用eclipce等后端环境工作，一大堆让前端迷糊的配置，一旦java人员更新了错误的文件，会导致所有人的环境启动不了，束手无策，只能等待救援。\n\n*   2、难维护：页面总是会有php\\jsp等非前端代码，相互干扰、无法优化，时间越久问题越突出。\n\n*   3、前后端职责不清晰。\n\n*   有人会问，分离为什么不全部走ajax，页面就不需要任何服务端语言了。但实际场景并非如此，首先有些数据总是要生成页面时就已经同步获取的，且全异步对SEO不利、纯html页面没有include功能等。\n网上还有其它的理解，大致相同就不列举了。\n \n### 三、如何做分离\n\n*   1、产品设计确定后，前后端人员共同制定开发接口，为方便接口的制定、显示、测试，使用nodejs+mongodb开发了接口平台。参见http://www.upopen.cn:8090/interface/index\n功能：制定接口时就直接在interface平台上新增录入ActionName、description、 method、 param 及 默认值 等并保存到mongodb，当后台开发完成后，直接用在该页面做接口测试，成功后方可交付，避免联调过程中的接口反复。（原本想用interface.upopen.cn 来测试同域名下的项目，但因cookie在不同二级域名下无法共享的问题，暂用了二级目录，不过已有方案，后续优化）\n \n*   2、从前端角度考虑系统架构图如下：\n\n*   前后端分离架构图\n\n![alt text][logo]\n\n[logo]: http://dl2.iteye.com/upload/attachment/0109/5335/aa3756e5-d06c-3431-aadf-30733d2d4466.png \"Logo Title Text 2\"\n\n*   访问入口 NGINX 代理静态资源到 STATIC 服务器，其它请求则到 NODEJS。\n\n*   页面请求NODEJS直接render，数据相关NODEJS则做预处理，再发到后台\n\n*   前端据已定义的接口，通过nodejs+mysql模拟后台完成数据存取，此处会增加些工作量，但只是为了走通业务流程，模拟后台数据表定义及逻辑无需严谨，只要能正常存取即可，如注册用户save to DB，登录验证read from DB，所以提供模式化的工具、写法后，新增表、接口，并不会多耗时间，nginx – nodejs – 模拟后台，即可按实际使用完成所有前端工作。\n\n*   QA单独测前端时，修改hostIP指向到测试工具。\n\n*   Java开发完成后接口，在 Interface平台 上验证所有接口，确认无误。QA也可以通过Interface测试Java接口\n\n*   nodejs修改config里的hostIP配置到java，理想情况下，修改此步配置即完成联调\n \n*   每个模块的简略部署如下：\n\n```js\nNginx.conf：\n     Location ~ \\.(jpg|png|css|js ){ //静态资源代理\n          Root /root/static/;\n     }\n     Location \\{ //其它接口转发\n     Proxy_pass http://upopen.cn;\n}\n…\nUpsteam upopen.cn{\n     Server http://node.upopen.cn;\n}\n```\n\n*   STATIC 结构如下：使用require.js做模块化加载工具，有朋友问为什么不用seajs，还问这两个优劣，其实前两年的项目用的都是seajs，此处想试试amd vs cmd，所以就用了require.js ，以目前的使用来看，相互可替代\n\n```js\nCore：[核心模块，主要是引入第三方必用、稳定模块]\n     Base.js [自定义通用函数]\n     Require.js\n     Jquery.js\n     Bootstrap.js\n     Backgone.js\n     Socket.io.js\n     I18n.js\n     …\nPublic: [业务级公共模块]\n     Validate.js [表单验证模块]\n     All.js [所有页面需要执行的业务js，如登录验证]\n     Zhdoc.js [国际化文本定义]\n     Reset.css [样式初始化]\n     common.css\n     …\nWidget: [自定义组件]\n     Dialog: [弹框组件]\n          Dialog.js\n          Dislog.css\n          Imgs: [弹框组件图片]\n     Calendar:[日志组件]\n          Calendar.js\n          Calendar.css\n          Imgs: [日历组件图片]\n     …\nModule: [业务模块]\n     Issue: [静态模块]\n          Index: [首页]\n               Index.js\n               Index.css\n               Imgs:\n          news: [新闻]\n               news.js\n               news.css\n               imgs:\n          …\n     User: [用户模块]\n          Register: [注册]\n               Register.js\n               Register.css\n               Imgs:\n          findPwd: [找回密码]\n               findPwd.js\n               findPwd.css\n               imgs:\n          …\nNodejs结构主要如下： express 框架\n     App.js\n     Package.json\n     Node_modules:\n     Routes:\n          Index.js – 路由入口，接收所有请求做转发，并做权限过滤、404等\n          Issue.js – 接收来自index.js的静态请求\n          User.js - 接收来自index.js的用户请求，页面请求render，数据请求转发\n          …\n     Views: [使用ejs框架，接收来自 routes 里的页面请求]\n          Common: [公用模块页]\n               Header.ejs\n               Footer.ejs\n               …\n          Issue: [静态模块页]\n               Index.ejs\n               News.ejs\n               …\n          User: [用户模块页]\n               Register.ejs\n               findPwd.ejs\n               …\n          Controls: [业务逻辑模块]\n               Config.js –公共配置模块，如hostIP、basePath等，切换环境修改此配置\n               User.js - 接收来自 route/user.js的数据请求，向外转发做逻辑准备\n               Tool.js - 封装常用函数如http.request/mailer/md5等\n               Redis.js - redis封装，对于单体封装内容比较多的模块，单独成立一个文件\n               …\n          Log: [日志，采用Log4js，日志是必须的，页面开发者常欠缺日志理念]\n         Assets: 结构、使用同 STATIC，不配置nginx时，调用此处资源，意义不大\n         …\nNodejs + MySql: [模拟后台模块，相对上面的模块，主要多了DB]\n     Db: [数据处理模块]\n          Mysql.js – 封装模式化数据存储接口，提供最便捷的新增表、接口的方法\n\n```\n\n*   按此结构完成前端所有功能，因目前项目较小，部分模块还有细分空间。\n \n \n### 四、分离结果如何\n\n*   1、开发效率更高，在联调之前，互不干扰，前端开发完成后就是实际可用的代码，不需要再转换成后台编译环境，永远不会被java / php 启动不成功所困扰。\n\n*   2、部分需要前后端共同开发的功能，如文件上传，通常需要页面端与接收端都进行相关的开发配置，之前较难定位是谁配置错误，现在全部由前端完成，开发、测试都容易定位，上传成功后，只要向java发送文件保存的路径即可。\n\n*   3、完全分清了前后端开发人员的职责，任一方开发完成后都可以提测，实现同步开发、测试。\n\n*   4、联调非常简单，若双方接口一致，正常情况下只要修改要接口请求IP即可完成切换。\n\n*   5、问题责任清晰，联调、测试、预发、上线，每个过程都难免会产生问题，前端、后端、运维三方责任边界清晰，日志中记录nodejs的请求发出，nginx请求接收与转发、java端请求接收与返回，三处任何一处断点，都能马上定位是哪方的问题。\n\n*   6、前端人员有更高的权限，页面端的展示几乎全由前端实现，但之前一些配置却受制于后台，比如常见的模板功能，纯html页面虽可以通过angularjs实现模板，但实际效果却并不理想，网速差时经常会出现include部分显示后置、甚至加载不成功的情况，nodejs的ejs框架可以很好的实现这个功能。\n\n*   另外，据浏览器加载不同的css以便实现浏览器兼容，之前处理通常是页面加载后，通过js判断浏览器类型，再去加载不同的css文件，影响渲染效率，并且js判断浏览器类型本身就存在兼容问题，用nodejs则可以在render前就完成该判断，直接用相应的浏览器样式做渲染\n\n*   7、代码复用，验证模块，页面端与nodejs端可以直接复用\n\n### 五、注意事项：\n\n*   1、前端开发人员不仅需要有扎实的nodejs知识，还要有一定的服务端、运维知识，对http通信有更深层次的理解，nginx、redis、socket、buffer等技术也要掌握，多多益善。\n\n*   2、开发之初对功能充分、宽裕的评估，使用初期不要用nodejs过多开发新功能。初次使用，难免会遇到很多意想不同的问题，前端开发人员本身对服务端知识有限，java人员又对nodejs语法不熟，若处理不好会导致项目延期。我原本认为redis同memcached一样就是connect + set + get，但实际开发时遇到一些考虑不周而产生的怪异问题，延长该部分开发时间，最终导致项目delay。\n\n*   3、前端开发人员可尝试用linux系统开发，第一版用win7开发时，npm部分模块的安装会不顺利，如node-canvas在win7上安装需要6步，而原本在32上已配置成功了，在64位上的系统上又不成功，后来该接口暂由java实现。实际上即使配置成功了，该模块在发布服务器的linux系统上也无法使用，需要重新安装。第二版开发时，我使用了ubuntu，虽然有一定的学习成本，但对后期的效率提升十分有益，多学习一种系统操作，和运维调试时也更加主动。不过ubuntu下没有找到做PSD切图的工具，所以安装双系统更合适切换使用。\n \n### 六、总结：\n\n*   目前用分离方式做了两版项目，开发效率提升、协作沟通便捷上有明显优势，作为前端也学习了很多新知识、扩大影响范围，是共赢的。目前使用还较初级，要继续学习、探索。在此贴出以便和同仁共进步之。\n","summary":"","title":"前后端分离项目实践","__v":0}
{"_id":{"$oid":"572945217297440b0aefad92"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n\n\u003e前段时间写了《前后端分离项目实践》\u003chttp://www.upopen.cn/article/info/559239adb269230039000001\u003e收到一些建议，又经过两个月的项目实践、整理，和大家再分享下，统一回复下疑问。\n\n\u003e其它相关文章可参考\u003chttp://www.upopen.cn\u003e\n \n### 二、新的架构图\n\n![alt text][pic]\n\n[pic]: http://www.upopen.cn/upload/article/201509011355.jpg \"Title Text 2\" \u0009\n\n\u003e标红线部分，由前端完成，相对于之前的结构，web服务端多了mobile 和 app，数据服务端在非敏感数据处也使用了mongo做数据库存储，按图的序号简单说下每块的职能。\n      \n\u003e1、nginx – 作为项目的入口，主要用于代理 及 负载。\n\n\u003e\u003e偏前端的朋友问既然nodejs可以做web服务器，为什么还要用nginx？在服务器的层面上nodejs可以启动为web服务器，但通常也仅限于此。在运维层面上要考虑代理、负载、process、gzip、cache、cgi...，这些不是nodejs可达到的，并且单从对静态资源的处理上，nginx就比nodejs高效很多，毕竟nginx号称理想情况下可以支持50000的并发，这和为什么不用nodejs完成所有的服务数据处理是一个道理。\n\n\u003e\u003e据文件和域名将请求代理到static和nodejs服务器\n\n\u003e\u003egzip / cache等其它功能      \n\n\u003e2、static用于存放js/css/imgs/ttf/less/woff等静态资源，要充分考虑据项目的文件目录细化、便于扩展、\n cdn部署等。 \n\n\u003e3、mobile web服务器\n\n\u003e4、pc web 服务器\n\n\u003e5、app web 服务器\n\n\u003e\u003e上面三个对应三个不同的客户端请求，在项目不明朗的情况下，尽量细化且少耦合是比较合适的。虽然在我公司项目实践上，三个服务主要都是对用户使用公司服务支持，但仍有较多的不同，所以单独分开，app部分正在开发，使用react native。\n\n\u003e\u003e此处不做数据存储，也有朋友说不做存储，其它也没什么事情可以做了。我们可以做\n\n\u003e\u003e* 请求路由指向\n\n\u003e\u003e* 数据过滤\n\n\u003e\u003e* 附件上传\n\n\u003e\u003e* 图片验证码\n\n\u003e\u003e* 页面静态化\n\n\u003e\u003e* 权限控制\n\u003e\u003e* ...\n\n\u003e\u003e这取决于你项目本身，如果是java，除了存储外的其它逻辑，都可以考虑用nodejs来实现。\n\n\u003e6、routes，配置向外的接口文件，控制请求流向\n\n\u003e7、使用mongodb + nodejs搭建数据库服务，\n\n\u003e\u003e此处主要用于存储一些非敏感性、轻计算的数据，如新闻等营销类数据，开发轻量，且非SQL数据库也便于扩展。我们官网的运营支撑平台就是完全由前端完成的。\n\n\u003e8、Redis存储缓存类数据\n\n\u003e\u003e暂存用户登录状态及角色等临时信息，单独使用SESSION无法处理多台服务器共享，可以自行生成SID对应用户信息保存在REDIS里。\n\n\u003e9、用户数据存储 online\n\n\u003e\u003e此处是常规意义的后台，因涉及较多的数据计算，我们用JAVA实现，各取所长。\n\n\u003e10、用户数据存储 DEV\n\n\u003e\u003e用于并行开发过程中为web服务提供测试数据，因为此处只是为WEB服务提供基本的数据存取不用考虑业务逻辑，实现起来也非常便捷，提供可模块化的方法、流程，对工作是非常有利的\n\n\u003e11、提供测试类数据\n\n\u003e\u003e此处主要是给QA使用，数据输出到其指定的工具，便捷查看及反馈\n\n\u003e12、其它第三方接口\n\n\u003e\u003e比如，我们手机网页也适用于微信服务号，涉及用户数据如OPENID获取等。\n\n\u003e13、使用nodejs+mongo额外提供一个接口测试工具，方便java人员在线测试，也作为接口交付依据。\n\n\u003e总体思想就是，尽量解耦，接口化，才能便于扩展、复用，减少重构成本。\n\n### 三、技术支持\n\n\u003e这样的项目，对前端人员的技术深度、广度有更高层面的要求，此时更是一个架构、全栈的角色，这样的角色需要哪些技能呢？\n\n\u003e首先，需要较好的技术团队，良好的运维、测试、JAVA开发同事，是项目顺利进行的保证，除此之外，前端人员需要掌握以下不限于的技术，\n\n\u003e\u003e1、 NODEJS，官网上的API\n\n\u003e\u003e2、 NODEJS各种框架，提高开发效率\n\n\u003e\u003e\u003ea) Express\n\n\u003e\u003e\u003eb) Ejs\n\n\u003e\u003e\u003ec) Node-dev\n\n\u003e\u003e\u003ed) Node-inspector\n\n\u003e\u003e\u003ee) Log4js\n\n\u003e\u003e\u003ef) Redis-server\n\n\u003e\u003e\u003eg) Mongoose\n\n\u003e\u003e\u003eh) Pm2\n\n\u003e\u003e\u003ei) grunt\n\n\u003e\u003e\u003e...\n\n\u003e\u003e3、 MONGODB / SQL\n\n\u003e\u003e4、 对http有更深刻的理解，理解其原理，掌握HEADER信息等\n\n\u003e\u003e5、 LINUX（UBUNTU）开发经验，提高开发效率，也便于与运维人员沟通\n\n\u003e\u003e6、 redis / socket / ...\n\n\u003e\u003e7、 更严谨的编辑思维，对测试、异常、日志等有较好的控制。\n\n\u003e可以参考教程\u003chttp://www.upopen.cn/article/info/559252e1b269230039000002\u003e，相信会对初学者有些帮助。\n\n\u003e教程git在https://github.com/xiaolulu/mynodejs.git\n\n### 四、人员\n\n\u003e这样的一个项目结构需要多少前端人员支持也大家最常问的，具体要视项目情况及从业人员的技术积累，有60分的积累，就可以尝试做70分的事情，这样才会成长。在前期探索阶段，先开发一些轻逻辑的应用，把时间多用在技术实现上。\n\n\u003e我刚进现在创业型公司三个月+，目前只有我一个，还在扩招。人手不足，所以在技术选择及业务支持上一直比较谨慎\n\n### 五、总结\n\n\u003e这样架构虽然提高了公司项目开发效率，但也并不比传统方式高明很多，更谈不上替代，并且需要我花费更多心力，但工作就是这样，自己学习、努力之外，还要去创造展示自己的平台，成长就在于你为自己搭了多高的门槛，让他人难以替代。\n\n\u003enodejs出现终究还较短，国内尚没有大规模应用，但通过一些国际企业的使用，我们可以预见其优势可以被我们所应用。特别对于互联网这种重页面交互、轻业务逻辑的web应用上，更能体现其价值。\n\n\u003e作为新事物，还有很多问题需要探索、解决，我们在路上。","summary":"","title":"前后端分离项目实践_扩展","__v":0}
{"_id":{"$oid":"572945c47297440b0aefad93"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n\n前端如何独立用nodeJs实现一个简单的注册、登录功能，是不是只用nodejs+sql就可以了？其实是可以实现，但离实际应用还有距离，那要怎么做才是实际可用的。\n\n网上有很多nodeJs的示例，包括和 sql / nginx … 等周边技术结合demo，但通常都是做为入门演示或解决某一问题，少有站在项目实际完整应用角度，给出一个整体的解决方案。一些前端朋友和我讨论nodejs时，也多表现出对服务端的欠缺，虽然知道nodejs很好，但难以实际应用。\n\n我在这块做了些研究，也在公司项目中有应用，在此和大家分享下，如何用nodejs实现一个实际可用的项目，需要操作的步骤及相关的技术应用。现在还没想好做怎样的一个demo，就随想随做，如有意义的需求我们也可以一起实现下，若有欠缺，也欢迎共同讨论。\n\n第一次做，我们就先实现下最常用的注册和登录。\n\n技术点：\n1. 用户注册站点，需要输入用户名、密码、邮箱，验证有效性。[ nodejs / express / validate / md5 / node-dev / requirejs ]\n2. 发送验证邮件，用户通过邮箱验证后，注册成功。[ mongodb / mailer ]\n3. 用户登录，可以访问需要登录权限的页面[ redis / 权限控制 ]\n4. 本项目在linux上开发 及 发布部署 [ git / nginx / ubuntu / aliyun / pm2 ]\n5. 考虑到前后端分离的需要，我们也将分别搭建前台服务（接收页面请求）、后台服务（数据存储） [ 项目架构 ]\n\n⋅⋅*因涉及到的技术点较多，在本项目中每一种技术如nginx只对使用到的部分做讲解，其它部分后面用到再讲，循序渐进，基础较弱者也好逐步接受。\n\n⋅⋅*本节，我们将实现unbuntu、nodejs、nginx的安装及初步使用，搭建一个可访问的服务\n\n## 二、linux环境\n本次开发将linux上开发，建议前端开发者尝试使用linux系统，其能拓展技术面，在提升开发、发布效率等方面也有好处，初次使用linux会有些障碍，不过现在linux也有类win7的漂亮桌面环境，操作大致相似，在命令不熟时也可以正常使用，坚持用两周，是可以适应的。\n\n选择系统上建议安装适合个人开发者的ubuntu。\n\n建议安装双系统，虚拟机太弱，完全安装ubuntu，使用又不便，有些软件如PS是不支持linux的。\n\nwin7下安装ubuntu 的双系统，WIN7安装ubutntu 步骤参见 http://www.upopen.cn/article/info?id=559291b3f0e6e0665b000001\n\n安装成功后，我们就开始提高B格之旅，接下来会对用到的linux操作做简单解释，具体的ubuntu教程可以参考  http://www.upopen.cn/article/info?id=55938b7ff0e6e0665b000003\n\n### 三、安装nodeJs\n\n快捷键 Ctrl + Alt + T 打开shell终端，\n\n1、打开Nodejs站点 https://nodejs.org/download/，下载linux下对应的.gz文件。也可以拷贝下载地址后，\n\n在shell里执行  wget     https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz。\n\n解释：wget ：下载后面路径指定的文件\n\n2、下载后默认在Downloads文件里，我们将压缩文件放Soft/node 目录里以便分类管理\n\nshell执行  mkdir Soft     // mkdir:  创建Soft文件夹\n\n执行 cd Downloads  //cd: 进入到 Downloads 下载文件目录\n\n执行 cp node-v0.12.5-linux-x64.tar.gz /home/cc/Soft\n                        //cp: 复制 node..gz到Soft目录下，注意cc是你的主机名，可通过pwd查看\n\n执行cd //进入个人根目录\n\n执行cd Soft/node\n\n执行 tar -zxvf  node-v0.12.5-linux-x64.tar.gz  //tar -zxvf  解压\n\n执行 mv  node-v0.12.5-linux-x64.tar.gz node //mv : 修改文件夹名为node\n\n执行sudo vi /etc/profile //打开环境变量配置文件\n\n在最后写入\n\n```js\nexport PATH=\"/home/cc/Soft/node/bin:$PATH\"\nexport NODE_PATH=\"/home/cc/Soft/node/lib/node_modules\"\n```\n// 环境变量地址参见 node的 pwd\n\n配置成功后重启\n\n作用：重启后，可执行node -v查看是否安装成功。\n\n解释：本部涉及到ubuntu的基本命令操作，都有简单的解释\n\n### 四、创建项目目录并安装express等框架包\n\n目录结构\n\nroot：项目根目录\n⋅⋅*web：前端服务\n⋅⋅*static：静态服务\n⋅⋅*server：后端服务\n\n1、执行 mkdir -p root/web\n\n作用：创建目录，所有项目都在root下，前端服务在web。创建成功后进入web文件夹 执行cd root/web\n\n2、执行touch package.json\n\n作用：创建 package.json文件，维护nodejs项目的依赖文件\n\n解释：touch ：创建文件\n\n4、执行 vi package.json\n\n作用：用系统的VI编辑器打开 package.json文件。用vi作大量的编辑工作是不适合的，我们还是用常规的编辑器，在桌面打开文件系统，进入我们创建的root/web目录，使用系统默认的gedit编辑器打开package.json\n\n5、通过gedit在package.json写入\n\n```javascript\n{\n⋅⋅\"name\": \"myCoolNodejs \",\n⋅⋅\"version\": \"0.0.1\",\n⋅⋅\"private\": true,\n⋅⋅\"scripts\": {\n⋅⋅⋅\"start\": \"node app.js\"\n⋅⋅},\n⋅⋅\"dependencies\": { //主要是这两处，设置引入模块，后面还会用到其它模块，另行添加\n⋅⋅⋅\"express\": \"*\",\n⋅⋅⋅\"ejs\": \"*\"\n⋅⋅}\n}\n```\n6、执行npm install\n\n作用：下载package.json中dependencies 定义的引入模块\n\n注意：有时限制于网络等因素npm install会安装不成功，可以使用淘宝的npm镜像，执行 npm install -g cnpm --registry=https://registry.npm.taobao.org，安装cnpm，执行cnpm install 。使用同npm。\n\n7、通过桌面打开 web文件夹，创建app.js，并写入基本配置\n```js\n        /**\n        * 引入依赖模块\n        */\n        var express    = require( 'express' ),\n        http              = require( 'http' ),\n        path             = require( 'path' );\n        \n        var app        = express(),\n        server     = http.Server( app );\n        \n        /**\n        * 设置\n        */\n        app.set( 'port', process.env.PORT || 3000 ); //服务启动端口\n        app.set( 'views', __dirname + '/views' ); //视图文件\n        app.set( 'view engine', 'ejs' ); //页面引擎\n        app.use( '/', express.static( path.join( __dirname, 'assets' ))); //静态文件路径\n        \n        app.get( '/', function( req, res ){\n                res.render( 'index.ejs' ); //请求跳转到 index.ejs文件\n        })\n        server.listen( app.get( 'port' ), function(){ //监听服务端口\n                console.log( 'root server listening on port ' + app.get( 'port' ));\n        } );\n\n        server.on( 'close', function(){\n                console.log( 'close' );    \n        } );\n```\n       \n8、web目录下创建views文件夹，里面再创建index.ejs文件作为首页\n\n9、打开index.ejs文件，并写入\n\n```js\n        \u003c!DOCTYPE html\u003e\n        \u003chtml\u003e\n        \u003chead\u003e\n        \u003ctitle\u003e我的nodejs项目\u003c/title\u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n            \u003ch1\u003e我的nodejs项目\u003c/h1\u003e\n            \u003cimg src=\"/public/imgs/logo.png\" /\u003e \u003c!-- 引用图片，是为测试后面配置静态服务器--\u003e\n        \u003c/body\u003e\n        \u003c/html\u003e\n```\n\n作用：ejs语法同html，优势在于其可以引用一些命令，如接收服务服务端定义的数据、include模板等\n\n        10、在web目录下创建文件夹 assets/public/imgs，拷入logo.png 图片\n\n        11、shell到web目录，执行 node app.js，在浏览器打开 127.0.0.1:3000，即可看到我们在index.ejs里设置的内容，如图\n\n        12、在root在创建 statc文件夹，作为静态服务资源，将目录web/assets/下的文件，复制到static里，下面nginx将设置静态文件代理到static服务器\n        \n### 五、安装nginx\n\n1、shell执行sudo apt-get install nginx\n\n作用：安装nginx服务器，nginx的使用可参见http://www.upopen.cn/article/info?id=559254e8b269230039000003\n\n2、执行sudo vi /etc/nginx/sites-enabled/default\n\n作用：因配置文件需要编辑的命令较少，我们尝试通过vi 编辑 nginx的配置文件。vi命令操作参见http://www.upopen.cn/article/list?kind=ubuntu\n\n        在server里增加\n```js\n        location  ~ \\.(png|jpg|css|js|woff|ttf|less|gif)$ {\n            root /home/jgc/root/static/;\n            #配置以上面结尾的文件都指向到 /home/cc/root/static。注意/cc/修改为你的计算机名\n        }\n        location / {\n            proxy_pass http://mynodejs.com;\n            #其它请求转向到 http://mynodejs.com; 该名称可以自定义\n        }\n```       \n        在server外面新增\n```js\n        upstream mynodejs.com { //此处名称与上面proxy_pass名称一致\n            server 127.0.0.1:3000;\n        #创建集群，为分摊服务器压力，可以创建多个服务器，做负载均衡，如果我们将web复制一份为web1，启动端口改为3001，将其启动后，此处可以再增加一条配置\n            server 127.0.0.1: 3001\n            # 这样访问便可随机指向3000 及 3001服务，分摊访问压力、降低服务宕机风险\n        }\n```\n        3、在shell 执行 sudo /etc/init.d/nginx start\n\n            作用：启动nginx服务\n\n        4、此时访问127.0.0.1也打开了和 3000一样的页面，不同在于其静态资源是从static文件夹获取的，可以通过删除web中的assets文件测试。我们后续静态文件都在statc里编辑，发布时static和web放在不同的服务器上，即实现了资源分离，为CDN做准备，\n\n        5、执行sudo vi /etc/hosts\n\n            作用：打开本地host映射文件，新增一条 127.0.0.1 www.mynodejs.com。保存后，浏览器访问 www.mynodejs.com。\n\n        \n        本节我们使用、开发了如下功能\n\n            1、ubuntu的安装和使用\n\n            2、nodejs的安装 及 模块安装\n\n            3、nodejs文件的简单配置和启动，项目目录的划分\n\n            4、nginx安装、简单配置 及 启动 [ 反向代理及集群 ]\n\n        \n        如果你原本只是一个单纯写html/css/js的前端开发员，相信这节是可以学到相当多的新知识，下节，我们将主要在nodejs及 mongo这一块，并按实际项目使用创建项目架构。\n\n        有不明或错误，欢迎加群讨论，谢谢。","summary":"","title":"NODEJS项目实践0.1","__v":0}
{"_id":{"$oid":"572946557297440b0aefad94"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n⋅⋅⋅通过上节学习，我们已经ubuntu系统搭建了一个可以访问的nodejs系统，并做了nginx转发。本节原要做web端服务 及 mongodb的存取，但写着写着，web端就写了很长，有些啰嗦，本着不重要的讲一遍，重要写三遍的原则，本节主要是讲适合初学者的web端服务搭建。mongodb下节再讲。\n\n---\n\n### 二、mongo\n\n#### 1、安装：\n\n⋅⋅⋅执行 sudo apt-get install mongodb\n\n⋅⋅⋅作用：安装mongodb，即安装成功，可以通过执行mongo，即可以看到mongo进入mongo的管理命令，并看到mongodb的版本号，mongo使用可参见\n\n⋅⋅*http://www.upopen.cn/article/info?id=559688a7f0e6e0665b000004\n\n### 二、web服务\n\n#### 1、实现路由功能\n\n⋅⋅⋅在web目录下创建routes目录，并创建index.js文件\n\n⋅⋅⋅作用：创建路由文件夹，上一节我们在app.js添加了app.get(...)代码，实现将用户访问指向到index.ejs，我们单独创建一个文件夹来归类所有请求，后面有大量工作都是做功能模块、文件的细分，前期细化对后期项目扩展有益\n\n⋅⋅⋅在/web/routes/index.js添加\n\n```js\n        exports.all = function( app ){\n            app.get( '/', function( req, res ){\n                res.render( 'index.ejs' );\n            })\n        }\n```\n\n⋅⋅⋅在/web/app.js里引用routes文件，并把app.get换成 routes里指向如下\n\n```js\n        var express    = require( 'express' ),\n                http              = require( 'http' ),\n                routes          = require( './routes' ), //新增routes引用\n                path             = require( 'path' );\n                ...\n        app.use( '/', express.static( path.join( __dirname, 'assets' )));\n        \n        routes.all( app ); //原app.get替换成 routes，所有的请求走routes.all里定义的函数\n        server.listen( app.get( 'port' ), function(){\n                console.log( 'root server listening on port ' + app.get( 'port' ));\n        } );\n        ...\n```\n\n⋅⋅⋅重新执行node.js，浏览器打开站点，功能可以同样使用。\n\n#### 2、模板功能。\n\n⋅⋅⋅页面 header / footer / menu 通常是共用的，我们用ejs的include实现\n\n⋅⋅⋅在views下创建common文件夹，存放页面的公用部分。\n\n⋅⋅⋅common下创建header.ejs文件，加入页头的公用部分，可以视情况到\u003cbody\u003e为止\n\n```js \n        \u003c!DOCTYPE html\u003e\n        \u003chtml\u003e\n        \u003chead\u003e\n        \u003ctitle\u003e我的nodejs项目\u003c/title\u003e\n        \u003clink href=\"/public/css/style.css\" rel=\"stylesheet\" \u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n```\n⋅⋅⋅引用了style.css的样式文件，自行在static下增加下。\n\n⋅⋅⋅同样创建footer.ejs文件\n\n```js\n        \u003cscript src=\"/core/js/jquery.min.js\"\u003e\u003c/script\u003e\n        \u003c/body\u003e\n        \u003c/html\u003e\n```\n\n⋅⋅⋅同样增加了jquery.min.js，在static下增加，这个js是放在core文件夹，与public区别开，用来放基本稳定的一些公用文件\n\n⋅⋅⋅在views下创建issue文件夹，把/views/index.ejs放到/views/issue里，归类存放站点不需要登录的资源\n\n```js\n        views --- common --- header.ejs\n                                     --- footer.ejs\n                        --- issue --- index.ejs\n```\n⋅⋅⋅index.ejs内include header.ejs/ footer.ejs\n\n```js\n        \u003c% include ../common/header.ejs %\u003e\n        \u003ch1\u003e我的nodejs项目\u003c/h1\u003e\n        \u003cimg src=\"/public/imgs/logo.png\" /\u003e\n        \u003c% include ../common/footer.ejs %\u003e\n```\n\n⋅⋅⋅这样我们即实现了模板功能，header.js及 footer.js自行丰富，通常css文件放在header里，js放footer里，对渲染效率有益。\n\n⋅⋅⋅注意： index.ejs的路径改了，路由指向index.ejs也要增加issue目录\n        \n#### 3、新增注册页面：\n\n⋅⋅⋅复制/web/views/index.ejs，重命名为 register.ejs，增加form\n\n```\n        \u003c% include ../common/header.ejs %\u003e\n        \u003cform\u003e\n            \u003clabel\u003e用户名: \u003cinput type=\"text\" id=\"username\" /\u003e\u003c/label\u003e\n            \u003clabel\u003e密码: \u003cinput type=\"text\" id=\"password\" /\u003e\u003c/label\u003e\n            \u003clabel\u003e邮件: \u003cinput type=\"text\" id=\"email\" /\u003e\u003c/label\u003e\n            \u003cbutton type=\"submit\"\u003e注册\u003c/button\u003e\n        \u003c/form\u003e\n        \u003c% include ../common/footer.ejs %\u003e\n```\n\n⋅⋅⋅在/web/routes文件夹下，复制index.js 为 issue.js，写入代码\n\n```js\n        function register( req, res ){ //定义注册转向\n            res.render( 'issue/register.ejs' );\n        }\n        module.exports = { //对外公开register函数\n            register: register\n        }\n```\n⋅⋅⋅修改routes/index.js\n\n```js\n        var issue = require( './issue' ); //引入issue.js文件\n        exports.all = function( app ){\n            app.get( '/', function( req, res ){\n                res.render( '/issue/index.ejs' );\n            });\n            app.get( '/register', function( req, res ){\n                issue.register( req, res ) //将register请求转向issue内的函数\n            });\n        }\n```\n⋅⋅⋅重启nodejs，访问 http://www.mynodejs.com/register。\n\n⋅⋅⋅后面我们频繁改动web里的文件，都需要重启才生效，影响效率，nodejs提供了node-dev模块，可以监听项目文件修改自动重启\n        \n#### 4、node-dev\n\n⋅⋅⋅执行：npm install -g node-dev\n\n⋅⋅⋅作用：将node-dev安装到全局模块\n\n⋅⋅⋅关闭原来启动的nodejs，重新执行  node-dev - - debug app.js 即可，后面再改服务端js，nodejs会自动重启\n        \n#### 5、页面文件个性化引用 及 静态文件目录\n\n⋅⋅⋅前面我们引用 了模板功能，header.ejs放公共文件，方便调用。但每个页面总有些个性化的信息及自己的css / js，此处用到了ejs的命令功能。\n\n⋅⋅⋅首先，在root/static下创建 module文件夹放所有页面的静态文件，再针对每个页面创建对应的静态文件夹\n\n⋅⋅⋅如 register，目录结构为\n        \n```js        \n        \n        \n        static ---module ---issue ---register ---register.css\n                                                                ---register.js\n                                                                ---imgs\n                                                   ---index ---index.css\n                                                                ---index.js\n                                                                ---imgs\n```   \n\n⋅⋅⋅整体结构与ejs下一致\n        \n⋅⋅⋅打开header.ejs文件，首先每个页面 的title是个性化的，css，也需要引用 针对本页面的定义css\n\n⋅⋅⋅修改如下\n\n```js\n        ...\n        \u003chead\u003e\n        \u003ctitle\u003e\u003c%= title %\u003e\u003c/title\u003e \u003c!--个性化定义title--\u003e\n        \u003clink href=\"\u003c%= basePath %\u003e/public/css/style.css\" rel=\"stylesheet\" \u003e\n        \u003clink href=\"\u003c%= basePath %\u003e/module\u003c%= currentPage %\u003e.css\" type=\"text/css\" rel=\"stylesheet\" \u003e \u003c!--个性化定义引入文件--\u003e\n        \u003c/head\u003e\n        …\n```\n\n⋅⋅⋅在root/web/下新建config文件夹，用来放站点一些配置信息，其下新建site.js，配置页面信息\n\n```js\n        var siteTitle = '优品开源', //站点名称\n                pageTitle = { //各页面名称\n                        '/': '首页',\n                        '/index': '首页',\n                        '/register': '注册'\n                },\n                basePath = 'http://www.mynodejs.com';  //设置页面根路径\n        module.exports = { //对外开放配置\n                setting: function( req, path, file ){\n                        return {\n                                title:       pageTitle[ req.path ] + '-' + siteTitle, //组成当前页面标题\n                                basePath:    basePath,\n                                currentPage: ( path || '' ) + ( file || req.path.replace(/(\\/[a-z|A-Z]*)?$/,function($1){return $1 + $1}) ), //据当前访问路径生成静态文件路径\n                       }\n                }\n        }\n\n```\n\n⋅⋅⋅修改web/routes/issue.js，把index.ejs的引入也放进来\n\n```js\n        var site = require( '../config/site' ); //引入site Config\n        function index( req, res ){\n                res.render( 'issue/index.ejs', site.setting( req, '/issue/index', '/index' ) );\n        } //首页没有页面路径，需要指定path及 filename\n        function register( req, res ){\n                res.render( 'issue/register.ejs', site.setting( req, '/issue' ) ); //配置信息，供ejs调用\n        }\n        module.exports = {\n                register: register\n        }\n```\n\n⋅⋅⋅配置完成，项目是node-dev启动，无需重启，再访问下首页，可以看到title是“首页-优品开源”，也引用了其自己的index.css，register也一样\n        \n#### 6、模块块管理 requireJs\n\n⋅⋅⋅js文件的调用，我们使用requireJs，使用参见\n\n⋅⋅⋅/web/view/common/footer.ejs，修改如下\n\n```html\n        \u003cscript type=\"text/javascript\" src=\"\u003c%= basePath %\u003e/core/jquery.min.js\"\u003e\u003c/script\u003e\n        \u003cscript type=\"text/javascript\" data-main=\"\u003c%= basePath %\u003e/module\u003c%= currentPage %\u003e.js\" src=\"\u003c%= basePath %\u003e/core/require.js\"\u003e\u003c/script\u003e\n        \u003c!-- js的路径引用模式同css--\u003e\n        \u003c/body\u003e\n        \u003c/html\u003e\n```\n\n⋅⋅⋅如jquery这种各页面都需要引用的js，建议不要通过模块引用，徒增计算。\n        \n#### 7、发送接收ajax请求\n\n⋅⋅⋅在 static/module/issue/register/register.js内增加ajax代码\n\n```js\n        define( function(){\n                $( '#registerForm' ).on( 'submit', function(){\n                        var data = {\n                                username: $('#username').val(),\n                                password: $('#password').val(),\n                                email: $('#email').val()\n                         };\n                        $.ajax({\n                                url: '/register',\n                                type: 'post',\n                                dataType: 'json',\n                                data: data,\n                                success: function( ret ){\n                                        console.log( ret );\n                                }\n                        });\n                        return false;\n                })\n        });\n```\n        \n⋅⋅⋅/web/routes/index.js 新增请求接收\n\n```js\n        app.post('/register', function( req, res ){\n                issue.registerUser( req, res );\n        });\n```\n\n⋅⋅⋅此处是app.post，对应ajax的type:'post'\n\n⋅⋅⋅/web/routes/issue.js 新增\n\n```js\n        function registerUser( req, res ){\n                res.send( { code: 0, msg: 'register info access success',data: req.body } );\n                //这里原本是要处理数据库存储操作，这里先走通ajax通信，验证能成功获取数据\n        }\n```\n⋅⋅⋅注意后面的 module.exports里要增加  registerUser\n        \n⋅⋅⋅通过 package.json 安装 body-parser 模块，方法见 0.1\n        \n⋅⋅⋅/web/app.js，新增\n\n```js\n        var express    = require( 'express' ),\n                ...\n                bodyParser = require( 'body-parser' ), //新增模块引用\n                ...\n                path             = require( 'path' );\n        \n        ...\n        app.use( '/', express.static( path.join( __dirname, 'assets' ))); //静态文件路径\n        app.use( bodyParser.urlencoded({ extended: false }));\n        …\n```\n\n⋅⋅⋅打开register，提交表单，打开调试工具，可以看到 ajax数据已经发送成功，并成功返回registerUser 里定义的数据\n\n⋅⋅⋅OK，到现在为止，我们安装Mongo、实现的路由、公共模板 及 其内个性化数据的定义，使用node-dev，并成功在register页面通过ajax与WEB服务端通信，下一节，我们将WEB服务端接收到的数据insert到db，并能 find，站点就完成了初步的注册、登录中的数据交互","summary":"","title":"公司项目NODEJS实践0.2[ express, ajax.. ]","__v":0}
{"_id":{"$oid":"5729471a7297440b0aefad95"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n\n⋅⋅⋅书接上回，我们搭建了WEB服务端路由、模板等功能，完成了register 通过ajax与后端的通信，今天主要完成数据与mongodb的存取，实现注册 / 登录 / 退出功能\n\n⋅⋅⋅DEMO GIT https://github.com/xiaolulu/mynodejs.git\n \n### 二、db操作\n\n⋅⋅⋅上一节我们已经安装过了mongo，本节主要是对其操作\n \n#### 1、mongoose\n\n⋅⋅⋅nodejs对 mongo的操作，我们使用 mongoose库\n\n⋅⋅⋅在package.json添加mongoose，并npm install\n\n⋅⋅⋅使用参考http://www.upopen.cn/article/info?id=559688a7f0e6e0665b000004\n        \n#### 2、/root/web目录下创建 db/sql.js，用于对mongoose的操作，添加如下代码\n\n```js\n        var mongoose = require( 'mongoose'  ); //引用模块\n        mongoose.connect( 'mongodb://127.0.0.1/myDB', function( err ){\n            //连接mongoose，连接本地127.0.0.1,mongo的默认端口是 27017\n            if( !err ){\n                console.log( 'DB == connect to mongodb' );\n            } else {\n                throw err;\n            }\n        } );\n        \n        var Schema = mongoose.Schema;\n        \n        var UserSchema = new Schema({ //创建User表模型，数据可据需求增减\n            username: String,\n            password: String,\n            email: String,\n            disabled: Boolean, //后面加注册后的邮件验证功能\n            date: Date,\n            power: Number  //后面会用到权限功能  \n        });\n        \n        var UserModel = mongoose.model( 'User', UserSchema, 'User' );\n        \n        function initData( data, db ){ //对参数做预处理，以防出现不合要求的参数，后面这块会做扩展\n            var query = {};\n            for( var key in data ){\n                if( db.tree[ key ] ){\n                    query[ key ] = data[ key ];\n                }\n            }\n            return query;\n        }\n        \n        function addUser( data, cb ){ //增加用户\n            data = initData( data, UserSchema );\n            ( new UserModel( data )).save( function( err, doc  ){\n                cb( err, doc );\n            })\n        }\n        function findUser( data, cb ){ //查找用户\n            data = initData( data, UserSchema );\n            UserModel.findOne( data ).exec( function( err, doc ){\n                cb( err, doc );\n            })\n        }\n        \n        module.exports = {\n            addUser: addUser,\n            findUser: findUser\n        }\n\n```\n        \n#### 3、在 /root/web下新建controls/user.js，用于处理路由与数据存储的中间逻辑，添加代码如下\n        \n```js\n        var db = require( '../db/sql' ); //添加前面定义的db操作模块\n        \n        function addUser( req, res ){ //增加用户\n            var data = req.body; //post过来的数据在req.body里，get过来的数据在req.query里\n            data.date = new Date(); //数据里增加时间\n            db.addUser( data, function( err, doc ){\n            if( !err ){\n                res.send( { code: 0, msg: 'add User Success', data: doc } );\n                //对查询结果返回，返回格式统一为 {code: 返回码, msg: 返回描述, data: 返回值}\n                }\n            })\n        }\n        \n        function findUser( req, res ){ //查找用户\n            var data = req.body;\n            db.addUser( data, function( err, doc ){\n                if( !err ){\n                    res.send(  { code: 0, msg: 'find User Success', data: doc }  );\n                }\n            })\n        }\n        \n        module.exports = {\n            addUser: addUser,\n            findUser: findUser\n        }\n```        \n        4、修改上节在/root/web/routes/issue.js定义的register函数改为\n\n```js\n\n        function registerUser( req, res ){\n            user.addUser( req, res );\n        }\n```\n\n⋅⋅⋅并增加 /web/controls/user.js的引用\n\n⋅⋅⋅再用node-dev启动项目，访问register，提交表单，可以看到返回成功，至此我们注册用户成功\n \n#### 5、使用shell mongo\n\n⋅⋅⋅打开shell，执行mongo，打开mongo终端\n\n⋅⋅⋅执行use myDB //切换到myDB数据库\n\n⋅⋅⋅执行db.User.find().pretty() //可以看到刚才我们新增的数据\n        \n#### 6、增加登录查询\n\n⋅⋅⋅在/root/web/views/issue下新建login.ejs，添加登录form。\n\n⋅⋅⋅在/root/static/module/issue 下新建 login的 js/css/img 静态文件，添加登录请求，如注册。\n\n⋅⋅⋅我们在db操作/db.sql.js里及业务处理/controls/user.js已经增加查询方法，只需在/routes/index.js 及 issue里增加 登录查询即可，这里不在列出，参考 register 流程即可。\n \n#### 7、session\n\n⋅⋅⋅上一步，我们走通了注册和登录查询功能，然后登录的目的是为了根据用户登录与否判断是否具备访问某些页面的权限。\n\n⋅⋅⋅这里简单说下session（后面再单独详解）：网站保存信息或状态，页面端常用的是cookie，而对应服务端是session，登录状态需要保存服务端以防伪造页面端。而http（后面再单独详解）是无状态的，为使页面端与服务端关联，生成session时，同时会在cookie里写入一个对应的id值，如 session_sid，每次页面与服务器的交互都会自动带上cookie，服务器端会据这个id查找是否有对应的session保存，从而形成状态保存。\n\n⋅⋅⋅这里我们也使用第三方库 express-session，安装同 mongoose\n\n⋅⋅⋅在 /root/web/routes/index.js里引入  express-session，并新增app.use如下\n\n```js\n        var issue = require( './issue' ),\n              session = require( 'express-session' ); //添加 express-session引用\n        exports.all = function( app ){\n            app.use( session({ //配置session\n                resave: false,\n                saveUninitialized: false,\n                secret: 'upopen'\n            }))\n            app.use( function( req, res, next){\n                if( req.path != '/login' \u0026\u0026 !req.session.status ){ //判断session状态是否是true\n                    res.redirect('/login'); //不是则跳转到登录页\n                } else {\n                    next(); //为true，则继续执行其请求\n                }\n            })\n            app.get( '/', function( req, res ){\n                issue.index( req, res );\n            });\n        …\n\n```\n        \n⋅⋅⋅上面的代码是对所有的页面做了限制，都必须是登录的状态才能访问，所以前端要先有注册成功的账号，这样的权限设置当然是不对的，我们只是做下测试。\n\n⋅⋅⋅打开/root/web/controls/user.js，在findUser函数下新增如下代码\n\n```js        \n        …\n        function findUser( req, res ){\n        var data = req.body;\n            db.findUser( data, function( err, doc ){\n                if( !err ){\n                    if( doc ){ //如果登录有查找结果\n                        req.session.status = true;        //则session里记录状态为true\n                    }\n                    res.send(  { code: 0, msg: 'find User Success', data: doc }  );\n                }\n            })\n        }\n        …\n```\n\n⋅⋅⋅再打开站点测试，发现，无论是访问index 还是 register都是自动跳转login，登录信息成功后，index和register都可以访问了，查看cookies里的信息，会看到 自动生成的connect.sid（名称可能不同），就是保存关联session的。手动删除connect.sid，所有页面又会都跳转到 login。\n\n⋅⋅⋅cookie使用，可参考 http://www.upopen.cn/article/info?id=559e2cbda46ee1885f000002\n\n⋅⋅⋅执行退出命令，只要设置req.session.status = false，即可。\n        \n#### 8、权限设置\n\n⋅⋅⋅上一步，增加了页面请求对权限登录的验证，但是验证只是针对某些页面的，我们把需要验证的路径罗列下来。\n\n⋅⋅⋅在/web/config下新增 privilege.js，用来罗列权限表，我们新增几个用户管理页面，用来表示权限需要\n\n```js\n\n        module.exports = {\n            '/user/center' : 1,\n            '/user/info': 1,\n            '/user/blog': 1\n        }\n```\n\n⋅⋅⋅修改 /root/web/routes/index.js，引入/web/config/privilege.js，修改验证是否登录的app.use\n\n```js\n        …\n        var privilege = require( '../config/privilege' );\n        …\n        app.use( function( req, res, next){\n            if( privilege[ req.path ] \u0026\u0026 req.path != '/login' \u0026\u0026 !req.session.status ){\n                //privilege[ req.path ] 判断该路径是否需要登录权限\n                if( req.method == 'GET' ){ //如果是get请求\n                    res.redirect('/login'); 则执行跳转\n                } else { //其它请求，基本都是POST，是不能直接redirect\n                    res.send( { code: 1001, msg: 'need you to log in'}); //则返回错误码，提示需要登录\n                }\n            } else {\n                next();\n            }\n        })\n        …\n\n``` \n\n⋅⋅⋅在web/routes 、web/views、status/module，新增对应的用户页面，user/blog，user/info，user/center，添加时注意文件夹的命名及细分。\n   \n⋅⋅⋅清除cookie，再访问 index 、register都是可以的，而user下的三个页面都需要登录。\n        \n\n#### 9、页面登录状态显示 及 退出\n\n⋅⋅⋅在/root/static/public/js 下新建 all.js，用于所有页面都要执行js\n\n⋅⋅⋅将页面据cookies判断登录状态的js写入，以便页面导航上 显示 登录 或 退出，通过requirejs，在每个页面引入。\n\n⋅⋅⋅退出，即给退出链接加一个get请求，/logout，在/routes/index.js里，添加logout\n\n```js\n         ...\n        app.get('/logout', function( req, res ){\n            req.session.status = false; //设置session状态为未登录\n            res.setHeader(\"Set-Cookie\",\"username=null;\" ); //清除cookie\n            res.redirect( '/' ); //跳转到首页\n        })\n        ...\n\n```\n \n### 三、至此我们完成了简单完成了注册及登录功能流程。\n\n⋅⋅⋅本节我们主要完成：\n\n⋅⋅⋅1、通过mongoose来操作mongo，完成数据增加和查询\n\n⋅⋅⋅2、通过session保存登录状态\n\n⋅⋅⋅3、完成注册 / 登录 / 退出\n\n⋅⋅⋅4、增加权限判断\n \n⋅⋅⋅本节我们虽然使用了session来记录登录状态，但实际使用时还是会有些问题，session是保存在本项目里的，如果上线后web服务端需要用多台计算机来负载，则状态不能共享。可以采用搭建验证服务器，即单独配置一个服务器来执行验证功能，也可以使用redis来保存登录状态。下节我们将使用redis来保存登录状态。\n \n⋅⋅⋅下节主要实现：\n\n⋅⋅⋅1、注册时的邮件验证\n\n⋅⋅⋅2、redis保存登录状态\n\n⋅⋅⋅3、nodejs异常处理，同步 and 异步\n\n⋅⋅⋅4、git操作","summary":"","title":"公司项目NODEJS实践0.3[ mongo / session ...]","__v":0}
{"_id":{"$oid":"572947867297440b0aefad96"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n\n⋅⋅⋅上节我们基于mongo数据存取的操作，实现了用户注册、登录、退出功能，并应用了初级的权限验证。本节将处理nodejs异常情况、加密、日志及进程守护。\n\n#### #git : https://github.com/xiaolulu/mynodejs.git\n\n### 二 、MD5\n\n⋅⋅⋅密码作为用户登录唯一凭证，其安全性不言而喻，前面我们的密码操作存在两个问题\n\n⋅⋅⋅a、用户登录及注册都使用了明文密码\n\n⋅⋅⋅b、数据库保存了用户的明文密码\n\n⋅⋅⋅常规可以使用二次加密，即前台传递到后台的密码先加密一次，后台再加密一次后存入数据库。\n\n#### 1、客户端加密\n\n⋅⋅⋅下载 md5.js 文件，用require包下。可以到我的git上下载，也是网上找的，加了require\n\n⋅⋅⋅该文件较稳定且与业务无关，我们放到 root/static/core/js内\n\n⋅⋅⋅在root/static/module/issue/register.js里引用，在password传输前对其加密\n\n```js\nrequire.config({\n\u0009baseUrl: basePath,\n\u0009paths: {\n\u0009\u0009all: 'public/js/all',\n\u0009\u0009md5: 'core/js/md5'\u0009//引用md5\n\u0009}\n})\n\ndefine( ['md5','all'], function( md5 ){\n    $( '#registerForm' ).on( 'submit', function(){\n        var data = {\n            username: $('#username').val(),\n            password: md5.hex_md5( $('#password').val() ),\u0009//对password加密\n            email: $('#email').val()  \n        }\n\u0009$.ajax\n\u0009...\n    })\n});\n```\n\n⋅⋅⋅此时通过mongo终端可以看到新注册的密码已经变成32的加密字段如\n\n⋅⋅⋅123456 → 'e10adc3949ba59abbe56e057f20f883e'\n\u0009\n#### 2、服务器端加密\n\n⋅⋅⋅在添加注册数据到数据库的时候，再加密一次\n\n⋅⋅⋅nodejs包装的加密模块为 crypto，通过package.json安装\n\n⋅⋅⋅对用户数据存取都在root/web/controls/user.js，我们对其修改\n\n```js\nvar db = require( '../db/sql' ),\ncrypto = require( 'crypto' );\u0009\u0009//引入  crypto 模块\nvar md5 = function(data) { \u0009//定义加密函数\n\u0009\n    return crypto.createHash('md5').update(data).digest('hex').toLowerCase();  \n\n} \nfunction addUser( req, res ){\n    var data = req.body;\n\u0009data.password = md5( data.password );\u0009//对存入的密码加密\n    ...\n}\n\nfunction findUser( req, res ){\n    var data = req.body;\n\u0009data.password = md5( data.password );\u0009//对查询的密码加密\n    ...\n}\n...\n```\n\n⋅⋅⋅此时我们再看数据库里的同样的密码，变化为另外一种32位的密文\n\n⋅⋅⋅如 123456 → '14e1b600b1fd579f47433b88e8d85291'\n\n⋅⋅⋅再执行一次注册 / 登录，功能是同样可用的，但密码已经是安全的了。\n\n⋅⋅⋅此时我们完成了加密，之所以二次加密是因为，客户端加密防止在向服务器传送的过程中被拦截，服务器再加密是防止内部出错。\n\n### 三 、nodejs异常处理\n\n⋅⋅⋅开发程序难免会出现代码异常，前台js情况还好些，通常只影响当前用户的当前页面，但服务器如果出现异常，则要严重的多，处理不慎会造成整个项目的崩溃，停止服务，所以后台的异常处理要非常全面。\n\n⋅⋅⋅js出提供了异常处理机制，就是我们常用的try{}catch(e){}，nodejs也可以使用\n\n#### 1、同步异常处理\n\n⋅⋅⋅编辑 root/web/routes/index.js，app.use是所有请求的入口，对其做下包装即可，在第二步中展示\n\n#### 2、异步异常处理\n\n⋅⋅⋅nodejs最主要的优势在于其非阻塞的IO机制，意味着其内有大量的异步回调，这里的错误是难以捕捉和处理的，也是try..catch所无法达到的，nodejs提供了domain方法，同样在 app.use里做处理\n\n```js\n…\nvar domain \u0009= require( 'domain' );\u0009//引入domain\nvar Domain = domain.create();\n\nDomain.on( 'error', function( e ){\u0009//监听异步错误\n\u0009console.log( 'error ' + e) \n});\n…\napp.use( function( req, res, next){\u0009\n\u0009\u0009try{\n\u0009\u0009\u0009if( privilege[ req.path ] \u0026\u0026 req.path != '/login' \u0026\u0026 !req.session.status ){\n                if( req.method == 'GET' ){\n\u0009\u0009            res.redirect('/login');\n\u0009\u0009            } else {\n\u0009\u0009                res.send( { code: 1001, msg: 'need you to log in'})    \n\u0009\u0009            }           \n\u0009\u0009    } else {\n\u0009\u0009\u0009Domain.run( function(){\n\u0009\u0009\u0009\u0009next();\u0009//包装异步处理，这样回调出错，也不会造成项目崩溃\n\u0009\u0009\u0009});\n\u0009\u0009    }\n\u0009\u0009} catch( e ){\n\u0009\u0009\u0009res.redirect( '/' );\n\u0009\u0009}\u0009\n        \n    });\n\n```\n### 四、pm2\n\n⋅⋅⋅在上一步我们做了异常处理，可以减少项目崩溃的机率，但其还是不够稳妥，下面我们使用进程守护模块。\n\n⋅⋅⋅pm2及forever模块是目前较常用的nodejs进程守护模块，前者更常用些、功能也更强大（提供负载）。其原理主要是pm2开启一个主进程，另行再开子进程运行nodejs项目，主进程监听子进程，若子进程崩溃，pm2会自行将其启动，并且也可以对一个项目启动多个子进程，pm2主进程做随机转发请求。\n\n#### 1、安装 npm install pm2 -g\n\n⋅⋅⋅其类似于前面我们安装的node-dev，是用于启动项目的，所以要安装在全局\n\n#### 2、常用命令\n\n```js\n\u0009pm2 start app.js\u0009//启动\n\u0009pm2 ls\u0009\u0009\u0009//显示已启动的项目进程，会显示项目id / name 负载等信息\n\u0009pm2 start app.js -i max //自动依赖电脑内核数，尽量启动多的进程\n\u0009pm2 reload all\u0009//重新加载\n\u0009pm2 restart [ app_name | id | all ]\u0009//重启项目，用于改了nodejs代码时，其不具备node-dev功能\n\u0009pm2 stop  [ app_name | id | all ]\u0009//停止某进程\n\u0009pm2 logs\n\n```\n### 五、log4js\n\n⋅⋅⋅后台项目日志是极其重要的，后端不是客户端 js那么明晰，错误可以随时debug，日志是很好的记录，其对所有数据的请求进行记录，也记录了出现危害项目的行为，如修改、删除数据操作。\n\n⋅⋅⋅我们使用log4js模块，通过package.json安装\n\n⋅⋅⋅在root/web下新建log文件夹存放日志文件\n\n⋅⋅⋅log4js还是需要一些简单的配置，前面使用md5及后面会到诸如ip获取等也需要一些简单的配置，我们将这些简单的不需要单独成一个文件的配置都放是一个文件里，新建 root/web/tool/gadget.js，添加代码如下\n\n```js\nvar log4js = require( 'log4js' );\n\u0009//引入log4js\n\nvar logConfig = {\n\u0009//设置配置项\n\u0009\"appenders\":[\n\u0009\u0009{\"type\": \"console\",\"category\":\"console\"},\n\u0009\u0009{\n\u0009\u0009\u0009\"type\": \"dateFile\",\n\u0009\u0009\u0009\"filename\":\"./log/\",\n\u0009//目录\n\u0009\u0009\u0009\"pattern\":\"yyyyMMdd.log\",\n\u0009//命名规则，我们是按天，也可以设置为yyyyMMddhh.log，为按时\n\u0009\u0009\u0009\"absolute\":true,\n\u0009\u0009\u0009\"alwaysIncludePattern\":true,\n\u0009\u0009\u0009\"category\":\"logInfo\"\n\u0009\u0009}\n\u0009],\n\u0009\"levels\":{\"logInfo\":\"DEBUG\"}\n}\n\nlog4js.configure( logConfig );\nvar logInfo = log4js.getLogger('logInfo');\n\nmodule.exports = {\n\u0009logInfo: logInfo\n}\n```\n\n⋅⋅⋅我们对所有的请求作记录，在root/web/routes/index.js，里的app.use处添加日志记录\n\n```js\nvar gadget = require( '../tool/gadget' );\n….\napp.use( function( req, res, next){\u0009\n\u0009\u0009console.log( req.path );  \n\u0009\u0009gadget.logInfo.info( req.path );\n\u0009//添加日志，记录所有请求路径\n\u0009\u0009try{\n\u0009\u0009\u0009if( privilege[ req.path ] \u0026\u0026 req.path != '/login' \u0026\u0026 !req.session.status ){\n\u0009\u0009\u0009\u0009console.log( req.session.status );\n                if( req.method == 'GET' ){\n\u0009\u0009            res.redirect('/login');\n\u0009\u0009            } else {\n\u0009\u0009                res.send( { code: 1001, msg: 'need you to log in'})    \n\u0009\u0009            }           \n\u0009\u0009    } else {\u0009\n\u0009\u0009\u0009\u0009Domain.run( function(){\n\u0009\u0009\u0009\u0009\u0009 next();\n\u0009\u0009\u0009\u0009});\n\u0009\u0009    }\n\u0009\u0009} catch( e ){\n\u0009\u0009\u0009gadget.logInfo.error( req.path );\n\u0009//添加日志，记录出错信息\n\u0009\u0009\u0009res.redirect( '/' );\n\u0009\u0009}\u0009\n        \n    })\n```\n\n⋅⋅⋅项目启动后，可以看到root/web/log下自动新增了 20150723.log文档，具体文件名视当前日期而定。\n\n⋅⋅⋅访问我们的站点的任一个页面，日志文件中都会自动多出相应的记录。\n\n⋅⋅⋅实时查看文档Linux下可用 tail -f 20150723.log，终端其会自动刷新目录数据。\n\n⋅⋅⋅本页的 Domain.on( 'error' )回调里也添加logInfo.error。还有DB的存取等所以有意义的数据往返及操作都可以记录下来\n\u0009\n\u0009\n### 六、总结\n\n⋅⋅⋅本节我们主要是对nodejs模块的应用，处理异常( domain)、加密了数据(md5)、设置进程守护(pm2) 并 做了日志记录（log4js），每一块只对基础配置使用做了介绍，后面再单独出一章详细nodejs常用模块\n\n⋅⋅⋅近来工作较忙，就先写到这里，下节演示nodejs分成前后台两部分接收页面请求及DB存取、git操作\n","summary":"","title":"NODEJS项目实践0.4 [domain,pm2,log4js,md5]","__v":0}
{"_id":{"$oid":"572947e87297440b0aefad97"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n\u0009\n上节我们主要应用了部分nodejs模块功能，本节我们再演示下nodejs常用的debug功能，git使用，并发布到阿里云，就完成了 0.*系统的教程。\n\nGIT：https://github.com/xiaolulu/mynodejs.git\n\n参考：http://www.upopen.cn\n\n### 二、调试模块\n\u0009\ndebug，即开发过程中的运行跟踪，是开发过程中的不可缺少的。如同页面端开发过程中，如果没有chrome的inspect element，开发过程中的问题排查，将是非常困难的。\n\n⋅⋅⋅nodejs目前常用的有两种类型的调试方案\n\n⋅⋅⋅1、以 webstorm为代表的开发编辑器类调试。webstrom本身支持很好的nodejs的开发体验，其也集成了测试功能，但这个不是我推荐的，自行百度 “ webstorm nodejs 调试 ”。\n\n⋅⋅⋅2、第二种是npm 下的 node-inspector，我使用的编辑器就是ubuntu下的gedit，即使在win7下使用的也是较古老的 edit plus，因为开发过程中，不需要什么提示功能，webstorm本身很大，启动起来也占用很大的资源。相比之下，gedit + node-inspector，则更加轻量。\n\n⋅⋅⋅全局安装：\n\n\u0009npm install -g node-inspector\n\n⋅⋅⋅启动\n\n⋅⋅⋅ssh执行   \n\n\u0009node-inspector\n\n⋅⋅⋅会提示 \n\n\u0009Visit http://127.0.0.1:8080/?ws=127.0.0.1:8080\u0026port=5858 to start debugging.\n\n⋅⋅⋅再开一个终端，cd到项目目录，执行 \n\n\u0009node-dev –debug app.js\n\n⋅⋅⋅上一节我们讲node-dev，使用了其自动 restarting，如果不需要高度，执行 node-dev app.js即可。\n\n⋅⋅⋅浏览器A打开  \n\n\u0009http://127.0.0.1:8080/?ws=127.0.0.1:8080\u0026port=5858\n\n⋅⋅⋅浏览器A即会显示成debug模式，\n\n⋅⋅⋅再用浏览器B打开我们项目，浏览器A就会显示nodejs端的代码，调用起来和页面端一样一样的。所以用 node-inspector可以安装后即可快速上手，不需要任何配置，使用起来不需额外成本，这也是我推荐的原因。\n\n⋅⋅⋅如下图：\n\n![alt text][logo]\n\n[logo]: http://upopen.cn/upload/nodejs/20150807001.png \"Logo Title Text 2\"\n\n### 三、git\n\u0009\n⋅⋅⋅git的常用命令可参见\n\n\u0009http://www.upopen.cn/article/list?kind=git\n\n⋅⋅⋅参照上面的教程，在 github上申请账号、新建项目、添加本地生成的key之后，就可以开始使用了。\n\n⋅⋅⋅cd到我们的项目 root，执行\n\n\u0009git init\u0009\n\n⋅⋅⋅将本地文件夹初即化为 git目录，通过 ls -la，可以看到其下多了.ssh的隐藏文件夹，用于存放git信息\n\n⋅⋅⋅执行\n\n\u0009git remote add origin git@github.com:\u003cyour-github\u003e/\u003cyour-project\u003e.git\n\n⋅⋅⋅将本地目录和远程目录关联起来\n\n\u0009git config -- global user.name \u003cyour name\u003e\n\n\u0009git config – global user.email \u003cyour email\u003e \n\n⋅⋅⋅配置自己的git信息，用于提交的记录author。\n\n\u0009git add *\n\n⋅⋅⋅添加所有的文件到暂存区\n\n\u0009git commit -m '我的第一个项目'\n\n⋅⋅⋅将暂存区的文件提交到 git 目录\n\n\u0009git push -u origin master\n\n⋅⋅⋅按提示输入你的git帐号及密码，将git 目录的文件提交到远程github上\n\n⋅⋅⋅我们即完成了本地代码的提交，具体命令解释及更多命令应用还是参照\n\n⋅⋅⋅http://www.upopen.cn/article/list?kind=git\n\n### 四、服务器\n\u0009\n⋅⋅⋅此处我使用的阿里云服务器，管理上简单些，选了个最低配置，1000/年，www.upopen.cn就是在阿里云上，七牛，百度也提供了这样的服务器。购买好服务器后，选择安装ubuntu系统。\n\n⋅⋅⋅连接服务器\n\n\u0009ssh \u003cyou server ip\u003e -l root\n\n⋅⋅⋅用户名先默认用 root即可。按提示输入密码即可登录\n\n⋅⋅⋅按项目约定安装，nginx / nodejs / mongo / git 等，并创建根目录\n\n⋅⋅⋅克隆远程库到本地\n\n\u0009git clone root git@github.com:xiaolulu/mynodejs.git\n\n⋅⋅⋅拉取远程库的数据到本地\n\n\u0009git pull origin master\n\n⋅⋅⋅在此我们使用了与上面git不同的命令，其实也可以按init/ remote来，为了多使用几个命令，另外，第三\n部分是新建库，此部主要是拉取。对后面的使用是一样的。\n\n⋅⋅⋅同样的配置成功后，访问该你的服务器IP，站点即发布成功。\n\n⋅⋅⋅如果有域名了更好，不过域名现在都需要备案了，需要些时间。\n\n### 五、validate.js\n\u0009\n⋅⋅⋅最后稍讲下页面端的js，原本不是我们本系列的重点，和大家探讨下，如何写一个可复用、解耦的组件，小微框架的思想也不过如此。\n\n⋅⋅⋅验证组件有很多种写法，但往往越高级的，限制性越大，我们写一个轻量级的，抛砖引玉。\n\n⋅⋅⋅首先我们分析下验证功能，得出以下一些原则\n\n⋅⋅⋅1、每个输入项都可以配置验证规则\n\n⋅⋅⋅2、可指定触发事件，如keyup或 change时触发验证\n\n⋅⋅⋅3、可配置一些通用的规则如非空、最小值、最大值、只能输入数字、字母、电话、身份证等\n\n⋅⋅⋅4、可配置自定义规则，如注册时，再次输入密码项的规则和密码项需一致。\n\n⋅⋅⋅5、提供错误提示的回调，往往错误提示形式是一致的，不需要提供回调，我们提供更自由的显示方式。\n\n⋅⋅⋅以注册页面表单为例，定义输入框的规则。在root/static/module/issue/register.js下新增\n\n```js\n\u0009var username = $( '#username' ),\n\u0009\u0009password = $( '#password' ),\n\u0009\u0009email = $( '#email' );\n\u0009//定义验证规则\n\u0009var usernameRule = [{\n\u0009\u0009\u0009'noBlank': '请输入用户名',\u0009//非空\n\u0009\u0009\u0009'min': [ 3, '用户名不能少于3位'],\u0009//最小\n\u0009\u0009\u0009'max': [ 16, '用户名长度不能多于16位'],\u0009//最大\n\u0009\u0009\u0009'typeEN': '用户名只能为字母及数字' \u0009//准输入类型\n\u0009\u0009}, function( prompt ){\u0009//错误提示回调\n\u0009\u0009\u0009$( '#usernameTip' ).html( prompt );\n\u0009\u0009}],\n\u0009\u0009passwordRule = [{\n\u0009\u0009\u0009'noBlank': '请输入密码',\n\u0009\u0009\u0009'self': function( cb ){\u0009//自定义规则\n\u0009\u0009\u0009\u0009cb( '密码不能全为数字' );\n\u0009\u0009\u0009\u0009return isNaN( this.value - 0 );\n\u0009\u0009\u0009}\n\u0009\u0009}],\n\u0009\u0009email = [{\n\u0009\u0009\u0009'noBlank': '请输入注册邮箱',\n\u0009\u0009\u0009'typeEmail': '邮箱格式不正确'\u0009//指定某定义规则\n\u0009\u0009}, function( prompt ){\n\u0009\u0009\u0009$( '#emailTip' ).html( prompt );\n\u0009\u0009}];\n\u0009\n\u0009//为指定指定表单添加指定触发事件的指定规则\n\u0009validate( username, [ 'keyup' ], usernameRule );\n\u0009validate( password, [ 'change' ], passwordRule );\n\u0009validate( email, [ 'foucsOut' ], emailRule );\n```\n\u0009\n⋅⋅⋅在root/static下新建 widget/，用于存放组件。其下新建  validate/validate.js\n\n```js\ndefine(function(  ){\n\n\u0009var isArray = function( value ){\n\u0009\u0009return Object.prototype.toString.call( value ) == '[object ]'\n\u0009}\n\u0009\n\u0009/*定义常用规则，通过判断值是否符合规则返回true / false */\n\u0009var Regular = {\n\u0009\u0009\n\u0009\u0009//非空\n\u0009\u0009noBlank: function( value ){\n\u0009\u0009\u0009return !!value;\n\u0009\u0009},\n\u0009\u0009//最小\n\u0009\u0009min: function( value, rule ){\n\u0009\u0009\u0009return value.length \u003e= rule;\n\u0009\u0009},\n\u0009\u0009//最大\n\u0009\u0009max: function( value, rule ){\n\u0009\u0009\u0009return value.length \u003c= rule;\n\u0009\u0009},\n\u0009\u0009//中文、英文\n\u0009\u0009typeZE: function( value ){\n\u0009\u0009\u0009return /^[\\u4E00-\\u9FA5\\uf900-\\ufa2d\\uFE30-\\uFFA0a-zA-Z]+$/.test( value );\n\u0009\u0009},\n\u0009\u0009//英文、数字\n\u0009\u0009typeEN: function( value ){\n\u0009\u0009\u0009return /^[0-9|a-z|A-Z]+$/.test( value );\n\u0009\u0009},\n\u0009\u0009//数字\n\u0009\u0009typeNum: function( value ){\n\u0009\u0009\u0009return !isNaN( value );\n\u0009\u0009},\n\u0009\u0009//电话\n\u0009\u0009typePhone: function( value ){\n\u0009\u0009\u0009return /^1[0-9]{10}$/.test( value );\n\u0009\u0009},\n\u0009\u0009//email\n\u0009\u0009typeEmail: function( value ){\n\u0009\u0009\u0009return /^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/.test(value)\n\u0009\u0009}\n\n\u0009}\n\u0009//循环对规则进行验证，主要分类两种。一种是self，一种是已定义的常用规则。\n\u0009function check( rules, cb ){\n\u0009\n\u0009\u0009var rule,\n\u0009\u0009\u0009prompt,\n\u0009\u0009\u0009codex,\n\u0009\u0009\u0009value = this.value;\n\u0009\u0009for ( rule in rules ){\n\n\u0009\u0009\u0009prompt = rules[ rule ];\n\u0009\u0009\u0009isArray( prompt ) \u0026\u0026 ( codex = prompt[0] ) \u0026\u0026 ( prompt = prompt[1] );\n\u0009\u0009\u0009//这里是针对 即带值，又带提示的规则 [ 3, '用户名不能少于3位']\n\u0009\u0009\u0009//否则只带提示的规则，如非空，电话号码等值可定的规则\n\u0009\u0009\u0009if( rule == 'self' ){\u0009//验证自定义的定义\n\u0009\u0009\u0009\u0009if( rules[ rule ].call( this, cb ) !== true ){\n\u0009\u0009\u0009\u0009\u0009return false;\n\u0009\u0009\u0009\u0009};\n\u0009\u0009\u0009} else if( !Regular[ rule ]( value, codex ) ){\u0009//验证上面定义过的规则\n\u0009\u0009\u0009\u0009cb( prompt )\n\u0009\u0009\u0009\u0009return false;\n\u0009\u0009\u0009}\n\u0009\u0009\u0009cb( '' );\n\u0009\u0009}\n\u0009\u0009return true;\n\n\u0009}\n\u0009//开始的验证函数，对某元素el添加指定事件events的验证规则rules，验证结果在cb中执行\n\u0009function validate( el, events, rules, cb ){\n\u0009\u0009\n\u0009\u0009if( rules ){\n\n\u0009\u0009\u0009cb = rules[1];\n\u0009\u0009\u0009rules = rules[0];\n\u0009\u0009\u0009$.each( events, function( k, event ){\n\u0009\u0009\u0009\u0009el.on( event, function(){\n\u0009\u0009\u0009\u0009\u0009check.call( this, rules, cb );\n\u0009\u0009\u0009\u0009});\n\n\u0009\u0009\u0009});\n\u0009\u0009\n\u0009\u0009} else {\n\u0009\u0009\u0009//这里是对不用传触发条件，直接进行验证的规则。主要是针对form.submit时需一次验证所有输入框时\n\u0009\u0009\u0009cb = events[1];\n\u0009\u0009\u0009rules = events[0];\n\u0009\u0009\u0009return check.call( el.get( 0 ), rules, cb );\n\u0009\u0009\n\u0009\u0009}\n\n\u0009}\n\u0009\n\u0009return validate\n\n})\n```\n\u0009\n⋅⋅⋅上面是写了一种较初级的验证函数，不过也可以解决大部分的验证场景，常用规则可自行添加。\n\n### 六、结语\n\n⋅⋅⋅至此，除了将数据存取部分和前台分离 及redis外，我们基本完成了0.1中所设定的功能，并应用到所列举的知识点，各知识点都是针对本项目使用了初级的功能。\n\n⋅⋅⋅简单总结下，前面5节所讲过的知识点：\n\n⋅⋅⋅1、安装、使用ubuntu，在Linux平台下开发项目，提高开发效率，扩展知识面。\n\n⋅⋅⋅2、使用nodejs，基于express、ejs框架，实现的基础的静态页面访问\n\n⋅⋅⋅3、使用nginx，搭建静态服务器，并做了代理转发及负载\n\n⋅⋅⋅4、据项目优化目录结构，做到分类明晰，静态、项目资源分离，各文件做意义划分，便于后面扩展\n\n⋅⋅⋅5、使用mongodb，实现了数据的存取，完成注册、登录等操作的客户端 - 服务端的数据交互\n\n⋅⋅⋅6、页面端使用requireJs来做模块管理并简单实现了验证模块。\n\n⋅⋅⋅7、使用了npm 的 node-dev[自启动]、md5[加密]、domain[异步异常]、pm2[进程守护]、log4js[服务日志]、node-inspector[开发调试]等模块。\n\n⋅⋅⋅8、实现了cookie和session的操作，保持用户登录状态\n\n⋅⋅⋅9、实现据登录状态的页面访问准入控制权限。\n\n⋅⋅⋅10、git操作，提交到服务器上。\n\n⋅⋅⋅上面的知识在项目上应用的较初级，后面对每个技术点都会做单独的文章补充，希望对我们都有所帮助，抛砖引玉，大家多做深入研究。\n\n⋅⋅⋅下一个系列的教程中，我们会对上面这些知识有个逐步高级的应用，并增加markdown，页面静态化，nodejs的单元测试等，这块在upopen.cn的文章系统上已经应用。\n\n⋅⋅⋅本部分的教程结束。谢谢！","summary":"","title":"NODEJS项目实践0.5 - 完结[inspector,git]","__v":0}
{"_id":{"$oid":"5729483b7297440b0aefad98"},"comment":0,"tags":"nodejs","kind":"nodejs","disabled":false,"view":0,"sort":0,"owner":"owner","date":{"$date":"2016-05-03T23:42:01.008Z"},"content":"### 一、前言\n\ngulp是一个适用于javascript的构建工具，能自动执行已定义的常见任务，如语法检测（jshint）、测试（mocha）、压缩（uglify）等。其相当于maven之于java。\n\n还有一个更早出现的构建工具grunt，其也提供了gulp的功能，且功能更为强大，但其在配置及使用上更为繁琐，其实现的理念也导致其编译效率较低，新出现gulp的出现正是为了解决这些问题，在后面的使用过程中将逐渐对比两者的优劣。\n\n官网： http://gulpjs.com/\n\n中文：http://www.gulpjs.com.cn/\n\n### 二、安装\n\n     npm install -g gulp\n\ngulp提供的是一个构建工具，要真正实现我们需要的功能，还需要下载相关的插件，如\n\n    npm install gulp-uglify --save-dev\n\n### 三、使用API：\n\n下面通过实现一个gulp的demo，来学习其API。\n\n创建gulp文件夹，新建gulpfile.js作为gulp的启动文件，插入如下代码\n\n     var gulp = require('gulp');\n\n     gulp.task( 'default', function(){\n        console.log( 'this is gulp default' );\n     });\n  \n使用cli进入到 gulp目录，执行gulp，其会自动找到gulpfile.js并执行，打印信息如下  \n \n     cc@cc:~/Work/gulp$ gulp\n     [07:23:15] Using gulpfile ~/Work/gulp/gulpfile.js\n     [07:23:15] Starting 'default'...\n     this is gulp default\n     [07:23:15] Finished 'default' after 133 μs\n\n执行完后会自动退出，后面会有不自动退出的情况，μs是微秒单位\n\n现在我们按一个较正规的系统目录，参照前面几章实现的项目。\n\ncli到gulp目录下，执行 npm init，自行配置相关描述，可如下\n\n     {\n        \"name\": \"gulp\",\n        \"version\": \"1.0.0\",\n        \"description\": \"this is a demo for gulp\",\n        \"main\": \"index.js\",\n        \"dependencies\": {},\n        \"scripts\": {\n            \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n        },\n        \"author\": \"upopen.cn\",\n        \"license\": \"ISC\"\n     }\n\ngulp下新建assets/core/js/base.js，插入\n\n     function base( name ){\n        console.log( 'this is base, hi ' + name );\n     }\n\n再新建assets/core/css/common.css，插入\n\n     body{\n        margin: 0;\n        padding: 0;\n        background: #afafaf;\n     }\n     a{\n        text-decoration: none;\n     }\n\n下载基于uglify的代码压缩插件 gulp-uglify\n\ncli执行    npm install gulp-uglify --save-dev\n\n修改gulpfile.js\n\n    var gulp = require( 'gulp' ),\n        uglify = require( 'gulp-uglify' );\n\n     gulp.task( 'default', function(){\n        gulp.src( 'assets/core/js/base.js' )\n            .pipe( uglify() )\n            .pipe( gulp.dest( 'assets_min' ) );\n     });\n\ncli执行gulp\n\n即实现了将assets/core/js/base.js压缩并插入到新建文件夹 assets_min内，和nodejs写法很相同，且条目简单，若用grunt做同样的功能则需要做相当多的配置。\n\ngulp的API总共有四个，我们一次就用到了其中的三个。\n\n-----\n1. gulp.task( name[, deps], fn )：创建一个任务\n\n     name: String 任务名\n     deps: Array 任务依赖，其会在任务之前执行\n     fn: Function 任务事件\n\ncli执行gulp时，默认会执行gulpfile.js里的default任务，若需执行其它任务，可以将其它任务作为default的deps，如\n\n     var gulp = require( 'gulp' ),\n        uglify = require( 'gulp-uglify' );\n\n     gulp.task( 'default', [ 'minify' ] );\n     gulp.task( 'minify', function(){\n        gulp.src( 'assets/core/js/base.js' )\n            .pipe( uglify() )\n            .pipe( gulp.dest( 'assets_min' ) );\n     });\n\n若只是想单独执行minify，也可以通过cli执行 gulp minify，来显示执行指定的task\n\nfn函数内的常见形式是 gulp.src( 'assets/core/js/base.js' ).pipe( uglify() )，读取文件.pipe( 执行压缩 ).pipe( 添加到文件夹  )，pipe是用流传递操作后的数据，下一个pipe接收到数据做操作后再向后传递，比起grunt的创建临时文件效率更高。可以通过输出src的引用查看\n\n     var stream = gulp.src( ... ).pipe( .. )\n     console.log( stream );\n\n文件流的工作原理 https://github.com/substack/stream-handbook\n\nfn 也支持异步的形式，需要在function添加实参cb，当异步返回时执行cb()即可，和mocha的回调添加实参done同理，如\n\n     var exec = require('child_process').exec;\n     gulp.task('jekyll', function(cb) {\n         exec('jekyll build', function(err) {\n             if (err) return cb(err);\n             cb();\n         });\n     });\n\n注意task默认将以最大的并发数执行，多个task之间不会相互等待，若需序列执行，注意使用deps 及 异步情况\n\n-----\n2. gulp.src( globs[, options ] )\n\n读取指定路径的文件，输出到piped的下一个插件中。\n\nglobs的语法 https://github.com/isaacs/node-glob\n\nglobs可以为Array / String，如上例中，可以是\n\n     'assets/core/js/base.js'\n    'asserts/*/*/base.js'\n    'asserts/*/*.js'\n    [ 'assets/*/*.js' ]\n\n更多匹配规则可以参考 https://github.com/isaacs/minimatch\n\n注意 \\* 的用法，/\\*.js，表示当前子目录的所有js文件，而/\\*/\\*.js，其N级下的子目录，即当有多层子目录时，不需要添加多层的\\*\n\noptions可以配置\n\n    buffer: true | false  是否以流的形式传播\n    read: true | false     是否可读\n    base: ''\n\n其中只base作为统一路径可能被使用外，其它两个基本不会使用，后面会用到base\n\n-----\ngulp.dest( path[, options ] )\n\n将接收到的数据输出到path下，若path不存在，会自动创建\n\n    path: String | Function，可据fun生成路径\n    options: 几乎不用\n          cwd: String 输出当前路径\n          mode: 0777，用于配置权限\n\n注：需要注意path的使用，其和gulp.src里的glob及 options里的base设置是相关，\n\n注意上例中以下几种情况\n\n     gulp.src( 'assets/core/js/base.js' ).pipe( gulp.dest( 'assets_min' ) ); //assets_min/base.js\n     gulp.src( 'assets/core/**/base.js' ).pipe( gulp.dest( 'assets_min' ) ); //assets_min/js/base.js\n     gulp.src( 'assets/**/**/base.js' ).pipe( gulp.dest( 'assets_min' ) ); //assets_min/core/js/base.js\n     gulp.src( 'assets/core/**/base.js',{base: 'assets'}).pipe( gulp.dest( 'assets_min' ) ); //assets_min/core/js/base.js\n\n可以看出path取的是 **部分，若设置了base，则取base后的部分。\n\n实现一个更复杂些的例子来表现gulp的用法。\n\n在assets/core/js/ 下与base.js同级新建common.js\n\n新增语法检测插件jshint，及文件组合插件concat。\n\ncli下执行 cnpm install gulp-jshint gulp-concat --save-dev \n\n修改gulpfile.js\n\n     var gulp = require( 'gulp' ),\n        uglify = require( 'gulp-uglify' ),\n        jshint = require( 'gulp-jshint' ),\n        concat = require( 'gulp-concat' );\n\n     gulp.task( 'default', function(){\n         gulp.src( 'assets/core/**/**.js',{ base: 'assets' } )\n             .pipe( jshint() )\n            .pipe( uglify() )\n            .pipe( concat( 'all.js' ) )\n            .pipe( gulp.dest( function(){ return 'assets_min' } ) )\n     });\n\n读取assets/core/js下的base.js、common.js --\u003e jshint语法检测 --\u003e uglify压缩 --\u003e concat合并为all.js --\u003e 添加到 assets_min 文件夹下\n\n再讲下gulp的第四个API\n\ngulp.watch( glob[, options ], task ); \n\ngulp.watch( glob[, options ], cb );\n\n    glob: String | Array  监听文件的路径\n    options:\n    tasks: Array 当被监听的文件变动时，需要执行task\n    cb: function 当文件变化时可执行的函数，\n\n在gulpfile.js文件里追加\n\n     gulp.watch( 'assets/**/**.js',  [ 'default' ] );\n     gulp.watch( 'assets/**/**.js', function( event ){\n        console.log( event );\n     })\n\ncli重新执行gulp，相比之前可以看到cli下并没有自动退出，此时修改assets/core/js/base.js保存后，cli自动显示执行了default，并且输出了{ type: 'changed',path: '/home/cc/Work/gulp/assets/core/js/common.js' }，即event表示文件的操作type及path。\n打开assets_min下的all.js，可以看到修改后的内容也已经添加进来了。\n\ngulp.watch本身会返回一个实例\n\n其提供了events( change | end | error | ready | nomatch ) 及 method ( end | files | add | remove )     \n\n上面为watch追加的代码，可以修改为\n\n     var watcher =gulp.watch( 'assets/**/**.js', [ 'default' ] );\n     watcher.on( 'change', function( event ){\n        console.log( event );\n     });\n\n可以达到同样的效果\n\n### 四、插件Plugin\n\ngulp作为一个构建工具，其只是提供了一个平台，可运行各款插件，以达到我们的项目需求，所以当我们学会使用gulp后，还需要了解其提供了哪些插件，甚至对没有提供的插件，我们可以自行封装。\n\n插件列表 http://gulpjs.com/plugins/\n\n常用的插件有\n\n    压缩CSS（gulp-minify-css）\n    语法检查（gulp-jshint）\n    文件拼接（gulp-concat）\n    文件压缩（gulp-uglify）\n    图片压缩（gulp-imagemin）\n    实时加载（gulp-livereload）\n    文件清理（gulp-clean）\n    更新通知（gulp-notify）\n    图片快取（gulp-cache）\n    Autoprefixer（gulp-autoprefixer）\n    \n当需要引用的插件列表较多时，可以使用gulp-load-plugins模块，代替所有插件的require，于是前面demo也可以写成\n\n     var gulp = require( 'gulp' ),\n        plugins = require( 'gulp-load-plugins' )();\n\n     gulp.task( 'default', function(){\n         gulp.src( 'assets/core/**/**.js',{ base: 'assets' } )\n            .pipe( plugins.jshint() )\n            .pipe( plugins.uglify() )\n            .pipe( plugins.concat( 'all.js' ) )\n            .pipe( gulp.dest( function(){ return 'assets_min' } ) );\n     });\n\n注意各插件的命名。\n\n五、browser-sync\n\n再介绍一个很酷的功能browser-sync。\n\n当我们修改html/css/js等静态资源文件时，需要刷新才能看到效果，如果做测试时填写了一堆表单，还需要重新来做，browser-sync就提供这样的功能。不过其目前只在修改css文件时做到单独加载，Html/Js 的自动刷新还是全页面的。\n\ncli上执行 npm install browser-sync --save-dev\n\n在当前demo下新建views/index.html，引入上例中的 css / js，如下\n\n     \u003c!DOCTYPE html\u003e\n     \u003chtml\u003e\n     \u003chead\u003e\n         \u003clink href=\"../assets/core/css/common.css\" type=\"text/css\" rel=\"stylesheet\" /\u003e\n     \u003c/head\u003e\n     \u003cbody\u003e\n         this is a demo for browser-sync\n         \u003cinput type=\"text\" /\u003e\n         \u003cscript src=\"../assets/core/js/common.js\"\u003e\u003c/script\u003e\n     \u003c/body\u003e\n     \u003c/html\u003e\n\n在gulpfile.js后追加代码\n\n     ...\n     var browserSync = require( 'browser-sync' );\n     ...\n     gulp.task( 'browser-sync', function(){\n        var files = [ 'views/*.html', 'assets/**/*.js', 'assets/**/*.css' ];\n        browserSync.init( files, {\n            server: { baseDir: '' }\n        })\n     })\n\n启动gulp，提示\n\n     cc@cc:~/Work/gulp$ gulp\n     [16:02:41] Using gulpfile ~/Work/gulp/gulpfile.js\n     [16:02:41] Starting 'browser-sync'...\n     [16:02:41] Finished 'browser-sync' after 35 ms\n     [16:02:41] Starting 'default'...\n     [16:02:41] Finished 'default' after 310 ms\n     [BS] Access URLs:\n    -------------------------------------\n    Local: http://localhost:3000\n    External: http://172.16.22.29:3000\n    -------------------------------------\n    UI: http://localhost:3001\n    UI External: http://172.16.22.29:3001\n    -------------------------------------\n     [BS] Serving files from: ./\n     [BS] Watching files...\n\n浏览器自动打开 localhost:3000，显示cannot get /，补全网址 localhost:3000/views/index.html，即打开了前面定义的html，此时对该html及引用的common.js /common.css的任何保存操作，都会导致资源自动更新，其中css的修改，只会更新当前资源，不会导致页面的整体刷新。","summary":"","title":"gulp api","__v":0}
